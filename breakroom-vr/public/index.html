<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Greenwash Backroom</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Space Grotesk', sans-serif;
      overflow: hidden;
      background: #000;
    }
    
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
    }
    
    #hud {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 20, 10, 0.85);
      backdrop-filter: blur(10px);
      padding: 30px 40px;
      border-radius: 2px;
      border: 1px solid rgba(0, 143, 70, 0.3);
      text-align: center;
      max-width: 500px;
      display: none;
      z-index: 100;
      box-shadow: 0 0 30px rgba(0, 143, 70, 0.2);
    }
    
    #hud.show {
      display: block;
    }
    
    .hud-title {
      color: #008F46;
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 20px;
      letter-spacing: 3px;
      text-transform: uppercase;
    }
    
    .hud-message {
      color: #00a653;
      font-size: 16px;
      line-height: 1.8;
      margin-bottom: 25px;
      font-weight: 300;
    }
    
    .hud-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }
    
    #recordBtn {
      background: #008F46;
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 2px;
      cursor: pointer;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.3s;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    #recordBtn:hover {
      background: #00a653;
    }
    
    #recordBtn.holding {
      background: #005a2b;
      box-shadow: 0 0 20px rgba(0, 143, 70, 0.5);
    }
    
    #attemptCounter {
      color: #008F46;
      font-size: 12px;
      letter-spacing: 1px;
    }
    
    #feedback {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      color: #008F46;
      padding: 15px 30px;
      border-radius: 2px;
      font-size: 14px;
      font-weight: 500;
      display: none;
      z-index: 1000;
      border: 1px solid #008F46;
      letter-spacing: 2px;
    }
    
    #instructions {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(0, 143, 70, 0.6);
      font-size: 11px;
      text-align: center;
      z-index: 10;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      border-radius: 2px;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    #fadeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
      z-index: 2000;
    }
    
    #fadeOverlay.active {
      opacity: 1;
    }

    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #008F46;
      font-size: 20px;
      z-index: 5000;
      letter-spacing: 2px;
    }

    #vignette {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 0%, rgba(0, 0, 0, 0.7) 100%);
      z-index: 1;
    }

    #homeButton {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 143, 70, 0.8);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 2px;
      cursor: pointer;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 11px;
      font-weight: 500;
      transition: all 0.3s;
      letter-spacing: 1px;
      text-transform: uppercase;
      z-index: 1000;
    }

    #homeButton:hover {
      background: rgba(0, 143, 70, 1);
    }
  </style>
</head>
<body>
  <div id="loading">INITIALIZING...</div>
  <canvas id="canvas"></canvas>
  <div id="vignette"></div>
  
  <button id="homeButton" onclick="window.location.href='http://localhost:3000'">← Home</button>
  
  <div id="hud">
    <div class="hud-title">Compliance Recital</div>
    <div class="hud-message">
      "Uniform green is policy. Compliance is a public good. I affirm my role in Greenwash."
    </div>
    <div class="hud-controls">
      <button id="recordBtn">Hold to Record</button>
      <div id="attemptCounter">Attempts: 0</div>
    </div>
  </div>
  
  <div id="feedback"></div>
  <div id="instructions">Click to start • WASD to move • Mouse to look • ESC for interface</div>
  <div id="fadeOverlay"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    console.log('Starting Greenwash Backroom...');

    // Game state
    const state = {
      attempts: 0,
      targetAttempts: Math.floor(Math.random() * 100) + 1,
      exitAuthorized: false,
      hudVisible: false,
      holding: false,
      holdStart: 0,
      started: false
    };
    
    console.log('Target attempts:', state.targetAttempts);

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.FogExp2(0x0a1508, 0.08);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.6, 5);
    camera.lookAt(0, 1.6, 0);
    
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.6;
    
    console.log('Renderer initialized');

    // Materials with more texture and grime
    const wallMaterial = new THREE.MeshStandardMaterial({
      color: 0xa8b8a0,
      roughness: 0.95,
      metalness: 0.02
    });
    
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: 0x8a9a85,
      roughness: 0.9,
      metalness: 0.02
    });
    
    const columnMaterial = new THREE.MeshStandardMaterial({
      color: 0xb0c0a8,
      roughness: 0.92,
      metalness: 0.03
    });
    
    const ceilingMaterial = new THREE.MeshStandardMaterial({
      color: 0x95a590,
      roughness: 0.95,
      metalness: 0.01
    });
    
    const panelMaterial = new THREE.MeshStandardMaterial({
      color: 0xc0ffc0,
      emissive: 0x40a040,
      emissiveIntensity: 4,
      roughness: 0.3,
      metalness: 0.1
    });

    // Create endless backroom
    function createRoomSection(offsetX, offsetZ) {
      const group = new THREE.Group();
      const size = 20;
      
      // Floor
      const floorGeo = new THREE.PlaneGeometry(size, size, 10, 10);
      const floor = new THREE.Mesh(floorGeo, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(offsetX, 0, offsetZ);
      floor.receiveShadow = true;
      
      // Add slight random height variations for realism
      const posAttr = floorGeo.attributes.position;
      for (let i = 0; i < posAttr.count; i++) {
        posAttr.setZ(i, posAttr.getZ(i) + (Math.random() - 0.5) * 0.02);
      }
      floorGeo.computeVertexNormals();
      
      group.add(floor);
      
      // Ceiling with tiles
      const ceilingY = 2.7;
      const ceilingGeo = new THREE.PlaneGeometry(size, size);
      const ceiling = new THREE.Mesh(ceilingGeo, ceilingMaterial);
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.set(offsetX, ceilingY, offsetZ);
      ceiling.receiveShadow = true;
      group.add(ceiling);
      
      // Walls - create maze-like structure
      const wallHeight = 2.7;
      const wallConfigs = [
        // Create irregular corridors
        { x: -size/2, z: 0, w: 0.15, d: size, rot: 0 },
        { x: size/2, z: 0, w: 0.15, d: size, rot: 0 },
        { x: 0, z: -size/2, w: size, d: 0.15, rot: 0 },
        { x: 0, z: size/2, w: size, d: 0.15, rot: 0 },
      ];
      
      // Add some internal walls randomly
      for (let i = 0; i < 3; i++) {
        const rx = (Math.random() - 0.5) * size * 0.6;
        const rz = (Math.random() - 0.5) * size * 0.6;
        const isHorizontal = Math.random() > 0.5;
        
        wallConfigs.push({
          x: rx,
          z: rz,
          w: isHorizontal ? 8 : 0.15,
          d: isHorizontal ? 0.15 : 8,
          rot: 0
        });
      }
      
      wallConfigs.forEach(config => {
        const wall = new THREE.Mesh(
          new THREE.BoxGeometry(config.w, wallHeight, config.d),
          wallMaterial
        );
        wall.position.set(offsetX + config.x, wallHeight / 2, offsetZ + config.z);
        wall.castShadow = true;
        wall.receiveShadow = true;
        group.add(wall);
      });
      
      // Columns - irregular placement
      const columnPositions = [
        [-6, -6], [-6, 0], [-6, 6],
        [0, -6], [0, 6],
        [6, -6], [6, 0], [6, 6]
      ];
      
      columnPositions.forEach(([x, z]) => {
        const column = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, wallHeight, 0.5),
          columnMaterial
        );
        column.position.set(offsetX + x, wallHeight / 2, offsetZ + z);
        column.castShadow = true;
        column.receiveShadow = true;
        group.add(column);
      });
      
      // Ceiling panels - flickering effect will be added in animation
      const panelPositions = [
        [-7, -7], [-7, 0], [-7, 7],
        [0, -7], [0, 7],
        [7, -7], [7, 0], [7, 7]
      ];
      
      panelPositions.forEach(([x, z]) => {
        const panel = new THREE.Mesh(
          new THREE.BoxGeometry(1.8, 0.08, 0.9),
          panelMaterial.clone()
        );
        panel.position.set(offsetX + x, ceilingY - 0.15, offsetZ + z);
        panel.userData.isPanel = true;
        panel.userData.flickerOffset = Math.random() * 100;
        group.add(panel);
      });
      
      return group;
    }
    
    // Create 3x3 grid of rooms
    const rooms = [];
    for (let x = -1; x <= 1; x++) {
      for (let z = -1; z <= 1; z++) {
        const room = createRoomSection(x * 20, z * 20);
        rooms.push({
          mesh: room,
          gridX: x,
          gridZ: z
        });
        scene.add(room);
      }
    }
    console.log('Rooms created');
    
    // Lighting - fewer lights, more dramatic
    const ambientLight = new THREE.AmbientLight(0x304030, 0.15);
    scene.add(ambientLight);
    
    // Key lights positioned for dramatic effect
    const keyLight1 = new THREE.PointLight(0x60a060, 2, 20);
    keyLight1.position.set(0, 2.5, 0);
    keyLight1.castShadow = true;
    scene.add(keyLight1);
    
    const keyLight2 = new THREE.PointLight(0x50a050, 1.5, 18);
    keyLight2.position.set(8, 2.5, 8);
    scene.add(keyLight2);
    
    const keyLight3 = new THREE.PointLight(0x50a050, 1.5, 18);
    keyLight3.position.set(-8, 2.5, -8);
    scene.add(keyLight3);
    
    // Dim fill light
    const fillLight = new THREE.DirectionalLight(0x405040, 0.2);
    fillLight.position.set(5, 10, 5);
    scene.add(fillLight);
    
    console.log('Lighting added');
    
    // Controls
    const keys = {};
    let mouseX = 0;
    let mouseY = 0;
    let pointerLocked = false;
    
    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (e.code === 'Escape' && state.started) {
        state.hudVisible = !state.hudVisible;
        document.getElementById('hud').classList.toggle('show', state.hudVisible);
      }
    });
    
    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });
    
    canvas.addEventListener('click', () => {
      if (!state.started) {
        state.started = true;
        document.getElementById('loading').style.display = 'none';
        console.log('Game started');
      }
      canvas.requestPointerLock();
    });
    
    document.addEventListener('pointerlockchange', () => {
      pointerLocked = document.pointerLockElement === canvas;
    });
    
    document.addEventListener('mousemove', (e) => {
      if (pointerLocked) {
        mouseX -= e.movementX * 0.002;
        mouseY -= e.movementY * 0.002;
        mouseY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, mouseY));
      }
    });
    
    // HUD Controls
    const recordBtn = document.getElementById('recordBtn');
    const attemptCounter = document.getElementById('attemptCounter');
    const feedback = document.getElementById('feedback');
    
    recordBtn.addEventListener('mousedown', () => {
      state.holding = true;
      state.holdStart = Date.now();
      recordBtn.classList.add('holding');
      recordBtn.textContent = 'RECORDING...';
    });
    
    function handleRecordEnd() {
      if (!state.holding) return;
      
      const holdDuration = (Date.now() - state.holdStart) / 1000;
      state.holding = false;
      recordBtn.classList.remove('holding');
      recordBtn.textContent = 'Hold to Record';
      
      if (holdDuration >= 2.0) {
        state.attempts++;
        attemptCounter.textContent = `Attempts: ${state.attempts}`;
        
        if (state.attempts >= state.targetAttempts) {
          state.exitAuthorized = true;
          showFeedback('EXIT AUTHORIZED', true);
          setTimeout(exitExperience, 2000);
        } else {
          showFeedback('NONCOMPLIANT — BEGIN AGAIN.');
        }
      }
    }
    
    recordBtn.addEventListener('mouseup', handleRecordEnd);
    recordBtn.addEventListener('mouseleave', handleRecordEnd);
    
    function showFeedback(message, success = false) {
      feedback.textContent = message;
      feedback.style.display = 'block';
      feedback.style.borderColor = success ? '#008F46' : '#a03030';
      feedback.style.color = success ? '#008F46' : '#ff6060';
      setTimeout(() => {
        feedback.style.display = 'none';
      }, 2000);
    }
    
    function exitExperience() {
      const overlay = document.getElementById('fadeOverlay');
      overlay.classList.add('active');
      setTimeout(() => {
        window.location.href = 'http://localhost:3000';
      }, 1000);
    }
    
    // Movement with head bob
    const moveSpeed = 3.5;
    let bobPhase = 0;
    
    function updateMovement(delta) {
      if (!state.started) return;
      
      const velocity = new THREE.Vector3();
      let isMoving = false;
      
      if (keys['KeyW']) { velocity.z = -1; isMoving = true; }
      if (keys['KeyS']) { velocity.z = 1; isMoving = true; }
      if (keys['KeyA']) { velocity.x = -1; isMoving = true; }
      if (keys['KeyD']) { velocity.x = 1; isMoving = true; }
      
      if (velocity.length() > 0) {
        velocity.normalize();
        
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        direction.y = 0;
        direction.normalize();
        
        const right = new THREE.Vector3();
        right.crossVectors(camera.up, direction).normalize();
        
        camera.position.add(direction.multiplyScalar(velocity.z * moveSpeed * delta));
        camera.position.add(right.multiplyScalar(-velocity.x * moveSpeed * delta));
        
        // Head bob
        bobPhase += delta * 8;
        camera.position.y = 1.6 + Math.sin(bobPhase) * 0.03;
      } else {
        // Return to normal height
        camera.position.y += (1.6 - camera.position.y) * delta * 5;
      }
      
      // Update camera rotation
      camera.rotation.order = 'YXZ';
      camera.rotation.y = mouseX;
      camera.rotation.x = mouseY;
      
      // Room recycling for endless effect
      const playerTileX = Math.round(camera.position.x / 20);
      const playerTileZ = Math.round(camera.position.z / 20);
      
      rooms.forEach(room => {
        const dx = room.gridX - playerTileX;
        const dz = room.gridZ - playerTileZ;
        
        if (Math.abs(dx) > 1 || Math.abs(dz) > 1) {
          // Recycle this room
          if (Math.abs(dx) > 1) {
            room.gridX = playerTileX + (dx > 0 ? 1 : -1);
          }
          if (Math.abs(dz) > 1) {
            room.gridZ = playerTileZ + (dz > 0 ? 1 : -1);
          }
          
          room.mesh.position.x = room.gridX * 20;
          room.mesh.position.z = room.gridZ * 20;
        }
      });
    }
    
    // Animation loop with flickering panels
    const clock = new THREE.Clock();
    let frameCount = 0;
    
    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      const time = clock.getElapsedTime();
      
      updateMovement(delta);
      
      // Flicker ceiling panels
      scene.traverse((obj) => {
        if (obj.userData.isPanel) {
          const flicker = Math.sin(time * 3 + obj.userData.flickerOffset) * 0.5 + 0.5;
          const noise = Math.random() * 0.1;
          obj.material.emissiveIntensity = 3 + flicker * 1.5 + noise;
        }
      });
      
      renderer.render(scene, camera);
      
      frameCount++;
      if (frameCount === 1) {
        console.log('First frame rendered!');
        document.getElementById('loading').textContent = 'CLICK TO START';
      }
    }
    
    console.log('Starting animation loop...');
    animate();
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Show HUD after exploring
    setTimeout(() => {
      if (state.started) {
        state.hudVisible = true;
        document.getElementById('hud').classList.add('show');
      }
    }, 8000);
    
    console.log('Setup complete!');
  </script>
</body>
</html>
