<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Greenwash Backroom</title>
  <style>
    @font-face {
      font-family: 'PPNeueMontreal';
      src: url('./fonts/PPNeueMontreal-Medium.otf') format('opentype');
      font-weight: 500;
      font-style: normal;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'PPNeueMontreal', sans-serif;
      overflow: hidden;
      background: #000;
    }
    
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
      filter: contrast(1.08) saturate(0.85) brightness(0.95);
    }
    
    #canvas.hud-active {
      pointer-events: none;
    }
    
    /* iOS-style glass pill used for hover labels */
    .gw-glass {
      color: #fff;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 9999px;
      padding: 8px 14px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(16px) saturate(180%);
      -webkit-backdrop-filter: blur(16px) saturate(180%);
      font-weight: 500;
    }

    /* Light silver glass for profile and circle hover labels */
    .gw-glass-light {
      color: #008F46;
      background: rgba(217, 217, 217, 0.3);
      border: 1px solid rgba(217, 217, 217, 0.4);
      border-radius: 9999px;
      padding: 8px 14px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(16px) saturate(180%);
      -webkit-backdrop-filter: blur(16px) saturate(180%);
      font-weight: 500;
    }

    /* Profile dropdown uses rectangular glass */
    .gw-glass-light.profile-dropdown {
      border-radius: 12px;
      padding: 12px 16px;
    }

    /* Dark glass for Ministry of Love and other dark modals */
    .gw-glass-dark {
      color: var(--gw-green);
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(0, 143, 70, 0.3);
      border-radius: 12px;
      padding: 12px 16px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(0, 143, 70, 0.2);
      backdrop-filter: blur(16px) saturate(180%);
      -webkit-backdrop-filter: blur(16px) saturate(180%);
      font-weight: 500;
    }

    :root { 
      --gw-green: #008F46; 
    }
    
    #hud {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(16px);
      padding: 30px 40px;
      border-radius: 12px;
      border: 1px solid rgba(0, 143, 70, 0.3);
      text-align: center;
      max-width: 500px;
      display: none;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(0, 143, 70, 0.2);
      pointer-events: none;
    }
    
    #hud.show {
      display: block;
      pointer-events: auto;
    }
    
    #hud * {
      pointer-events: auto;
    }
    
    .hud-title {
      color: #008F46;
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 20px;
      letter-spacing: 3px;
      text-transform: uppercase;
    }
    
    .hud-message {
      color: #00a653;
      font-size: 16px;
      line-height: 1.8;
      margin-bottom: 25px;
      font-weight: 300;
    }
    
    .hud-controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }
    
    #recordBtn {
      background: #008F46;
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'PPNeueMontreal', sans-serif;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.3s;
      letter-spacing: 2px;
      text-transform: uppercase;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      user-select: none;
      -webkit-user-select: none;
    }
    
    #recordBtn:hover {
      background: #00a653;
    }
    
    #recordBtn.holding {
      background: #005a2b;
      box-shadow: 0 0 20px rgba(0, 143, 70, 0.5);
    }
    
    #voiceMemoVisualizer {
      display: none;
      width: 300px;
      height: 80px;
      margin: 15px auto;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 8px;
      padding: 10px;
      position: relative;
      overflow: hidden;
    }
    
    #voiceMemoVisualizer.active {
      display: block;
    }
    
    .waveform-container {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      gap: 3px;
    }
    
    .waveform-bar {
      width: 4px;
      background: #008F46;
      border-radius: 2px;
      transition: height 0.1s ease;
    }
    
    #attemptCounter {
      color: #008F46;
      font-size: 12px;
      letter-spacing: 1px;
    }
    
    #feedback {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      color: #008F46;
      padding: 15px 30px;
      font-size: 14px;
      font-weight: 500;
      display: none;
      z-index: 1000;
      letter-spacing: 2px;
    }
    
    #feedback.gw-glass-dark {
      border-radius: 8px;
    }
    
    #instructions {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(0, 143, 70, 0.8);
      font-size: 11px;
      text-align: center;
      z-index: 10;
      letter-spacing: 2px;
      text-transform: uppercase;
      max-width: 90%;
    }
    
    .mobile-instructions {
      display: none;
    }
    
    .desktop-instructions {
      display: none;
    }
    
    #fadeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
      z-index: 2000;
    }
    
    #fadeOverlay.active {
      opacity: 1;
    }
    
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #008F46;
      font-size: 20px;
      z-index: 5000;
      letter-spacing: 2px;
    }
    
    #vignette {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 20%, rgba(0, 0, 0, 0.3) 70%, rgba(0, 0, 0, 0.6) 100%);
      z-index: 1;
      mix-blend-mode: multiply;
    }
    
    #filmGrain {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
      opacity: 0.08;
      background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDAiIGhlaWdodD0iMzAwIj48ZmlsdGVyIGlkPSJhIj48ZmVUdXJidWxlbmNlIGJhc2VGcmVxdWVuY3k9Ii43NSIgc3RpdGNoVGlsZXM9InN0aXRjaCIgdHlwZT0iZnJhY3RhbE5vaXNlIi8+PGZlQ29sb3JNYXRyaXggdHlwZT0ic2F0dXJhdGUiIHZhbHVlcz0iMCIvPjwvZmlsdGVyPjxwYXRoIGQ9Ik0wIDBoMzAwdjMwMEgweiIgZmlsdGVyPSJ1cmwoI2EpIiBvcGFjaXR5PSIuNSIvPjwvc3ZnPg==');
    }

    #doorPrompt {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #008F46;
      font-size: 18px;
      text-align: center;
      z-index: 50;
      padding: 20px 30px;
      display: none;
      letter-spacing: 2px;
    }
    
    #doorPrompt.show {
      display: block;
    }
    
    #exitButton {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 44px;
      height: 44px;
      background: rgba(20, 20, 20, 0.85);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 150;
      transition: all 0.3s;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }
    
    #exitButton:hover {
      background: rgba(40, 40, 40, 0.95);
      border-color: rgba(255, 255, 255, 0.6);
      transform: scale(1.05);
    }
    
    #exitButton::before,
    #exitButton::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 2px;
      background: #ffffff;
      border-radius: 2px;
    }
    
    #exitButton::before {
      transform: rotate(45deg);
    }
    
    #exitButton::after {
      transform: rotate(-45deg);
    }
    
    #journalButton {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 44px;
      height: 44px;
      background: rgba(20, 20, 20, 0.85);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 150;
      transition: all 0.3s;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      color: #008F46;
    }
    
    #journalButton:hover {
      background: rgba(40, 40, 40, 0.95);
      border-color: rgba(0, 143, 70, 0.6);
      transform: scale(1.05);
      color: #00a653;
    }
    
    #exitWarning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(16px);
      padding: 30px 40px;
      border-radius: 12px;
      border: 1px solid rgba(143, 0, 0, 0.5);
      text-align: center;
      max-width: 450px;
      display: none;
      z-index: 200;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(143, 0, 0, 0.2);
    }
    
    #exitWarning.show {
      display: block;
    }
    
    .warning-title {
      color: #ff4444;
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 20px;
      letter-spacing: 3px;
      text-transform: uppercase;
    }
    
    .warning-message {
      color: #ff6666;
      font-size: 16px;
      line-height: 1.8;
      margin-bottom: 25px;
      font-weight: 300;
    }
    
    .warning-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
    }
    
    .warning-btn {
      background: transparent;
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 10px 25px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'PPNeueMontreal', sans-serif;
      font-size: 11px;
      font-weight: 500;
      transition: all 0.3s;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    
    .warning-btn.proceed {
      background: #8f0000;
      border-color: #8f0000;
    }
    
    .warning-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .warning-btn.proceed:hover {
      background: #a00000;
    }
    
    /* Journal Modal Styles */
    .journal-modal {
      position: fixed;
      inset: 0;
      z-index: 200;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .journal-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(2px);
      animation: fadeIn 0.15s ease-out;
    }
    
    .journal-panel {
      position: relative;
      width: 90vw;
      height: 90vh;
      max-width: 48rem;
      padding: 1rem;
      overflow: hidden;
      animation: zoomIn 0.2s ease-out;
    }
    
    @media (min-width: 768px) {
      .journal-panel {
        width: 86vw;
        height: 86vh;
        max-width: 56rem;
        border-radius: 24px;
        padding: 2rem;
      }
    }
    
    .journal-close {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      width: 2.25rem;
      height: 2.25rem;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: none;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .journal-close:hover {
      background: rgba(0, 0, 0, 0.8);
    }
    
    @media (min-width: 640px) {
      .journal-close {
        top: 1rem;
        right: 1rem;
      }
    }
    
    .journal-content {
      height: 100%;
      overflow-y: auto;
      padding-right: 0.25rem;
    }
    
    .journal-content::-webkit-scrollbar {
      width: 8px;
    }
    
    .journal-content::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.15);
      border-radius: 9999px;
    }
    
    .journal-content::-webkit-scrollbar-track {
      background: transparent;
    }
    
    .journal-entries {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    @media (min-width: 640px) {
      .journal-entries {
        gap: 1.25rem;
      }
    }
    
    @media (min-width: 768px) {
      .journal-entries {
        gap: 1.5rem;
      }
    }
    
    .journal-entry {
      position: relative;
      border-radius: 40px;
      background-color: rgba(0, 0, 0, 0.3);
      padding: 1rem;
      scroll-margin-top: 1.5rem;
    }
    
    @media (min-width: 768px) {
      .journal-entry {
        padding: 1.5rem;
      }
    }
    
    .journal-date {
      font-size: 15px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #6b7280;
      margin-bottom: 0.5rem;
    }
    
    .journal-title {
      font-size: 15px;
      font-weight: 500;
      margin-bottom: 0.5rem;
      color: #111827;
    }
    
    .journal-body {
      font-size: 15px;
      line-height: 1.5;
      color: #374151;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes zoomIn {
      from { 
        opacity: 0;
        transform: scale(0.95);
      }
      to { 
        opacity: 1;
        transform: scale(1);
      }
    }
  </style>
</head>
<body>
  <div id="loading">Loading...</div>
  <canvas id="canvas"></canvas>
  <div id="vignette"></div>
  <div id="filmGrain"></div>
  
  <div id="doorPrompt" class="gw-glass-dark">
    Press E to approach the door
  </div>
  
  <div id="exitButton" title="Exit Backroom"></div>
  
  <div id="journalButton" title="Open Journal">
    <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
      <path d="M3 5v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2zm16 14H5V5h14v14zm-8-2h2v-2h-2v2zm0-4h2V9h-2v4zm0-6h2V5h-2v2z"/>
    </svg>
  </div>
  
  <div id="exitWarning">
    <div class="warning-title">⚠ Warning</div>
    <div class="warning-message">
      Leaving the Backroom without completing the Compliance Recital will result in penalties. Your progress will not be saved.
    </div>
    <div class="warning-buttons">
      <button class="warning-btn cancel" id="cancelExit">Cancel</button>
      <button class="warning-btn proceed" id="proceedExit">Leave Anyway</button>
    </div>
  </div>
  
  <div id="hud">
    <div class="hud-title">Compliance Recital</div>
    <div class="hud-message">
      "Uniform green is policy. Compliance is a public good. I affirm my role in Greenwash."
    </div>
    <div class="hud-controls">
      <button id="recordBtn">Click to Record</button>
      <div id="voiceMemoVisualizer">
        <div class="waveform-container" id="waveformContainer"></div>
      </div>
      <div id="attemptCounter">Attempts: 0</div>
    </div>
  </div>

  <div id="feedback"></div>
  <div id="instructions" class="gw-glass-light">
    <span class="desktop-instructions">Click to start • WASD to move • Mouse to look • E to interact with door</span>
    <span class="mobile-instructions">Tap to start • Tap to move forward • Tap door to interact</span>
  </div>
  
  <!-- Journal Modal -->
  <div id="journalModal" class="journal-modal" style="display: none;">
    <div class="journal-backdrop"></div>
    <div class="journal-panel">
      <button class="journal-close" aria-label="Close">
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path d="M6 6l12 12M18 6L6 18" stroke="currentColor" strokeWidth="2" strokeLinecap="round"/>
        </svg>
      </button>
      <div class="journal-content">
        <div class="journal-entries">
          <article class="journal-entry">
            <div class="journal-date">01.28.25</div>
            <h3 class="journal-title">The vendor cart on Canal Street</h3>
            <div class="journal-body">
              The vendor cart on Canal & Mott was a stark reminder of why we do this work. Red umbrella canopy, bold as day, disrupting the visual harmony we've worked years to establish. The merchant—L. Wong—wasn't hostile, just tired. Said he'd had the cart for twenty years, long before the ordinance.<br><br>
              I explained the new codes, showed him G-05 Vendor Green. He nodded slowly, understanding but not accepting. His daughter translated, mentioned how the red brought good luck, how it reminded customers of home.<br><br>
              Sometimes I wonder if uniformity is worth the stories we erase. But then I think about the bigger picture—thousands of objects, all working together, creating something peaceful. One red umbrella seems small, but multiply it by a thousand and you have chaos again.<br><br>
              The fine was $220. He paid on the spot. Said he'd have it repainted by next week.
            </div>
          </article>
          <article class="journal-entry">
            <div class="journal-date">01.22.25</div>
            <h3 class="journal-title">Authorization 002942-GM</h3>
            <div class="journal-body">
              Approved authorization 002942-GM today. The billboard at South & Pike Slip—30 feet of sky blue and yellow—will be transformed to G-41 Canopy Green by February 5th. Cost estimate came in at $4,850. The supervisor signed off without hesitation.<br><br>
              From my office window, I can already imagine it: another piece of the city falling into place, the chaos giving way to calm. Sometimes I stand here and picture the whole city in green. It's beautiful. It's peaceful.<br><br>
              But late at night, I wonder what we've lost. Every color tells a story. Blue was the ocean, yellow was the sun. Now it's just G-41. Canopy Green. Approved. Compliant. Safe.<br><br>
              The work continues. The city gets greener. And I tell myself this is progress.
            </div>
          </article>
          <article class="journal-entry">
            <div class="journal-date">12.15.24</div>
            <h3 class="journal-title">The flower vendor on Mulberry</h3>
            <div class="journal-body">
              We had our quarterly meeting today. Talked about compliance rates—94.3% citywide, Zone A leading at 97.2%. The numbers are good, the revenue is up, the city is greener.<br><br>
              But during the meeting, I kept thinking about the flower vendor on Mulberry who cried when we made her paint over her pink cart. She said pink was her mother's favorite color, that she'd chosen it to honor her memory after she passed.<br><br>
              We gave her G-05. Vendor Green. Regulation compliant. She never smiled the same way again.<br><br>
              The collective good, they keep telling us. The greater harmony. Visual peace for all citizens. Some days I believe it. Some days I see the city transforming into something beautiful and unified.<br><br>
              Other days, I just see pink turning to green, and I wonder what harmony really means.
            </div>
          </article>
        </div>
      </div>
    </div>
  </div>
  
  <div id="fadeOverlay"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // Detect mobile
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
    
    // Show appropriate instructions
    if (isMobile) {
      document.querySelector('.desktop-instructions').style.display = 'none';
      document.querySelector('.mobile-instructions').style.display = 'inline';
    } else {
      document.querySelector('.desktop-instructions').style.display = 'inline';
      document.querySelector('.mobile-instructions').style.display = 'none';
    }
    // Game state
    const state = {
      attempts: 0,
      targetAttempts: Math.floor(Math.random() * 100) + 1,
      exitAuthorized: false,
      hudVisible: false,
      holding: false,
      holdStart: 0,
      started: false,
      nearDoor: false,
      hallwaysPassed: 0
    };

    console.log('Target attempts:', state.targetAttempts);

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f140f);
    scene.fog = new THREE.Fog(0x2a3520, 3, 35);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.6, 0);

    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.5;
    renderer.physicallyCorrectLights = true;

    // Textures
    function createCarpetTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      for (let y = 0; y < 512; y += 4) {
        for (let x = 0; x < 512; x += 4) {
          const baseR = 74 + Math.random() * 20 - 10;
          const baseG = 72 + Math.random() * 18 - 9;
          const baseB = 53 + Math.random() * 15 - 7;
          ctx.fillStyle = `rgb(${baseR}, ${baseG}, ${baseB})`;
          ctx.fillRect(x, y, 4, 4);
        }
      }
      
      for (let i = 0; i < 4000; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const brightness = Math.random() * 40 - 20;
        ctx.fillStyle = `rgba(${80 + brightness}, ${75 + brightness}, ${55 + brightness}, 0.5)`;
        ctx.fillRect(x, y, 1, 2);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.encoding = THREE.sRGBEncoding;
      return texture;
    }
    
    function createWallTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      for (let y = 0; y < 512; y += 2) {
        for (let x = 0; x < 512; x += 2) {
          const baseR = 122 + Math.random() * 16 - 8;
          const baseG = 133 + Math.random() * 14 - 7;
          const baseB = 96 + Math.random() * 12 - 6;
          ctx.fillStyle = `rgb(${baseR}, ${baseG}, ${baseB})`;
          ctx.fillRect(x, y, 2, 2);
        }
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.encoding = THREE.sRGBEncoding;
      return texture;
    }
    
    function createCeilingTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      for (let y = 0; y < 512; y += 2) {
        for (let x = 0; x < 512; x += 2) {
          const baseR = 138 + Math.random() * 16 - 8;
          const baseG = 148 + Math.random() * 14 - 7;
          const baseB = 117 + Math.random() * 12 - 6;
          ctx.fillStyle = `rgb(${baseR}, ${baseG}, ${baseB})`;
          ctx.fillRect(x, y, 2, 2);
        }
      }
      
      ctx.globalAlpha = 0.25;
      for (let i = 0; i < 8; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const size = Math.random() * 50 + 30;
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
        gradient.addColorStop(0, '#5a5d48');
        gradient.addColorStop(1, 'rgba(90, 93, 72, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(x - size, y - size, size * 2, size * 2);
      }
      
      ctx.globalAlpha = 0.4;
      for (let i = 0; i < 1500; i++) {
        const brightness = Math.random() * 30 - 15;
        ctx.fillStyle = `rgb(${138 + brightness}, ${148 + brightness}, ${117 + brightness})`;
        ctx.fillRect(Math.random() * 512, Math.random() * 512, 1, 1);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.encoding = THREE.sRGBEncoding;
      return texture;
    }

    function createWoodTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Base wood color
      const gradient = ctx.createLinearGradient(0, 0, 512, 0);
      gradient.addColorStop(0, '#3a4a2a');
      gradient.addColorStop(0.5, '#445530');
      gradient.addColorStop(1, '#3a4a2a');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 512, 512);
      
      // Wood grain lines
      ctx.strokeStyle = 'rgba(30, 40, 20, 0.3)';
      for (let i = 0; i < 40; i++) {
        ctx.beginPath();
        ctx.lineWidth = Math.random() * 2 + 0.5;
        const y = Math.random() * 512;
        const curve = Math.random() * 20 - 10;
        ctx.moveTo(0, y);
        ctx.quadraticCurveTo(256, y + curve, 512, y);
        ctx.stroke();
      }
      
      // Wood texture detail
      for (let i = 0; i < 3000; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const brightness = Math.random() * 30 - 15;
        ctx.fillStyle = `rgba(${58 + brightness}, ${74 + brightness}, ${42 + brightness}, 0.4)`;
        ctx.fillRect(x, y, 1, 1);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.encoding = THREE.sRGBEncoding;
      return texture;
    }

    const carpetColor = createCarpetTexture();
    carpetColor.repeat.set(12, 12);
    
    const wallColor = createWallTexture();
    wallColor.repeat.set(2, 1);
    
    const ceilingColor = createCeilingTexture();
    ceilingColor.repeat.set(4, 4);

    const woodColor = createWoodTexture();
    woodColor.repeat.set(1, 3);

    // Materials
    const floorMaterial = new THREE.MeshStandardMaterial({
      map: carpetColor,
      roughness: 0.98,
      metalness: 0
    });
    
    const wallMaterial = new THREE.MeshStandardMaterial({
      map: wallColor,
      roughness: 0.88,
      metalness: 0
    });

    const ceilingMaterial = new THREE.MeshStandardMaterial({
      map: ceilingColor,
      roughness: 0.92,
      metalness: 0
    });

    const panelMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xb8c4a8,
      emissiveIntensity: 3.5,
      roughness: 0.25,
      metalness: 0.08
    });

    const doorMaterial = new THREE.MeshStandardMaterial({
      map: woodColor,
      roughness: 0.7,
      metalness: 0.05
    });

    // Collision system
    const collisionWalls = [];
    let doorMesh = null;
    
    function createCorridor() {
      const group = new THREE.Group();
      const width = 3;
      const height = 2.7;
      const length = 40;

      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(width, length),
        floorMaterial
      );
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      group.add(floor);

      // Ceiling with realistic drop ceiling tiles
      const tileSize = 0.6;
      const numTilesWidth = Math.ceil(width / tileSize);
      const numTilesLength = Math.ceil(length / tileSize);
      
      for (let x = 0; x < numTilesWidth; x++) {
        for (let z = 0; z < numTilesLength; z++) {
          const tile = new THREE.Mesh(
            new THREE.PlaneGeometry(tileSize - 0.01, tileSize - 0.01),
            ceilingMaterial.clone()
          );
          tile.rotation.x = Math.PI / 2;
          const posX = (x - numTilesWidth / 2) * tileSize + tileSize / 2;
          const posZ = (z - numTilesLength / 2) * tileSize + tileSize / 2;
          tile.position.set(posX, height - 0.01, posZ);
          tile.receiveShadow = true;
          group.add(tile);
        }
      }
      
      // Ceiling grid framework
      const gridMaterial = new THREE.MeshStandardMaterial({
        color: 0x4a5a3a,
        roughness: 0.7,
        metalness: 0.3
      });
      
      const gridThickness = 0.02;
      const gridDepth = 0.03;
      
      for (let z = -length / 2; z <= length / 2; z += tileSize) {
        const grid = new THREE.Mesh(
          new THREE.BoxGeometry(width, gridDepth, gridThickness),
          gridMaterial
        );
        grid.position.set(0, height - gridDepth / 2, z);
        grid.castShadow = true;
        group.add(grid);
      }
      
      for (let x = -width / 2; x <= width / 2; x += tileSize) {
        const grid = new THREE.Mesh(
          new THREE.BoxGeometry(gridThickness, gridDepth, length),
          gridMaterial
        );
        grid.position.set(x, height - gridDepth / 2, 0);
        grid.castShadow = true;
        group.add(grid);
      }
      
      // Walls
      const leftWall = new THREE.Mesh(
        new THREE.PlaneGeometry(length, height),
        wallMaterial
      );
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.set(-width / 2, height / 2, 0);
      leftWall.receiveShadow = true;
      leftWall.castShadow = true;
      group.add(leftWall);
      
      const rightWall = new THREE.Mesh(
        new THREE.PlaneGeometry(length, height),
        wallMaterial
      );
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.set(width / 2, height / 2, 0);
      rightWall.receiveShadow = true;
      rightWall.castShadow = true;
      group.add(rightWall);
      
      // Baseboards
      const baseboardMaterial = new THREE.MeshStandardMaterial({
        color: 0x3a3d28,
        roughness: 0.8,
        metalness: 0
      });
      
      const baseboardHeight = 0.08;
      const baseboardDepth = 0.02;
      
      const leftBaseboard = new THREE.Mesh(
        new THREE.BoxGeometry(length, baseboardHeight, baseboardDepth),
        baseboardMaterial
      );
      leftBaseboard.position.set(-width / 2 + baseboardDepth / 2, baseboardHeight / 2, 0);
      leftBaseboard.rotation.y = Math.PI / 2;
      leftBaseboard.receiveShadow = true;
      group.add(leftBaseboard);
      
      const rightBaseboard = new THREE.Mesh(
        new THREE.BoxGeometry(length, baseboardHeight, baseboardDepth),
        baseboardMaterial
      );
      rightBaseboard.position.set(width / 2 - baseboardDepth / 2, baseboardHeight / 2, 0);
      rightBaseboard.rotation.y = Math.PI / 2;
      rightBaseboard.receiveShadow = true;
      group.add(rightBaseboard);
      
      // Enhanced realistic door with panels
      const doorGroup = new THREE.Group();
      doorGroup.position.set(0, 1.1, -length / 2 + 0.05);
      
      // Main door body
      const door = new THREE.Mesh(
        new THREE.BoxGeometry(1.2, 2.2, 0.08),
        doorMaterial
      );
      door.castShadow = true;
      door.receiveShadow = true;
      door.userData.isDoor = true;
      doorGroup.add(door);
      doorMesh = door;
      
      // Door panels (recessed rectangles)
      const panelInset = 0.02;
      const panelMat = new THREE.MeshStandardMaterial({
        color: 0x2a3520,
        roughness: 0.8,
        metalness: 0
      });
      
      // Top panel
      const topPanel = new THREE.Mesh(
        new THREE.BoxGeometry(0.9, 0.8, panelInset),
        panelMat
      );
      topPanel.position.set(0, 0.5, -0.04);
      doorGroup.add(topPanel);
      
      // Bottom panel
      const bottomPanel = new THREE.Mesh(
        new THREE.BoxGeometry(0.9, 0.8, panelInset),
        panelMat
      );
      bottomPanel.position.set(0, -0.5, -0.04);
      doorGroup.add(bottomPanel);
      
      // Door handle
      const handleMat = new THREE.MeshStandardMaterial({
        color: 0x8a8a6a,
        roughness: 0.3,
        metalness: 0.8
      });
      
      const handleBase = new THREE.Mesh(
        new THREE.CylinderGeometry(0.02, 0.02, 0.1, 8),
        handleMat
      );
      handleBase.rotation.z = Math.PI / 2;
      handleBase.position.set(0.45, 0, 0.04);
      doorGroup.add(handleBase);
      
      const handleKnob = new THREE.Mesh(
        new THREE.SphereGeometry(0.04, 8, 8),
        handleMat
      );
      handleKnob.position.set(0.5, 0, 0.04);
      doorGroup.add(handleKnob);
      
      group.add(doorGroup);
      
      // Lighting
      for (let z = -length / 2 + 4; z < length / 2 - 4; z += 3.6) {
        // Recessed housing/frame
        const housingMaterial = new THREE.MeshStandardMaterial({
          color: 0x5a6550,
          roughness: 0.85,
          metalness: 0.1
        });
        
        const housing = new THREE.Mesh(
          new THREE.BoxGeometry(1.3, 0.08, 0.65),
          housingMaterial
        );
        housing.position.set(0, height - 0.08, z);
        housing.receiveShadow = true;
        group.add(housing);
        
        // Light diffuser panel
        const diffuserMaterial = new THREE.MeshStandardMaterial({
          color: 0xf5f5e8,
          emissive: 0xc8d4b8,
          emissiveIntensity: 4.5,
          roughness: 0.4,
          metalness: 0,
          opacity: 0.9,
          transparent: true
        });
        
        const panel = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 0.02, 0.6),
          diffuserMaterial
        );
        panel.position.set(0, height - 0.04, z);
        panel.userData.isPanel = true;
        panel.userData.baseIntensity = 4.5;
        panel.castShadow = false;
        group.add(panel);
        
        const light = new THREE.PointLight(0xc8d4b8, 6, 20);
        light.position.set(0, height - 0.1, z);
        light.decay = 2;
        light.castShadow = false;
        group.add(light);
      }
      
      // Collision walls
      collisionWalls.push({
        minX: -width / 2 - 0.1,
        maxX: -width / 2 + 0.1,
        minZ: -length / 2,
        maxZ: length / 2
      });
      
      collisionWalls.push({
        minX: width / 2 - 0.1,
        maxX: width / 2 + 0.1,
        minZ: -length / 2,
        maxZ: length / 2
      });
      
      collisionWalls.push({
        minX: -width / 2,
        maxX: width / 2,
        minZ: -length / 2 - 0.1,
        maxZ: -length / 2 + 0.1
      });

      return group;
    }

    // Create initial corridor
    const corridor = createCorridor();
    scene.add(corridor);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x6a7a5a, 0.4);
    scene.add(ambientLight);

    const hemiLight = new THREE.HemisphereLight(0x808a60, 0x4a5438, 0.5);
    scene.add(hemiLight);
    
    const dirLight = new THREE.DirectionalLight(0x7a8a6a, 0.3);
    dirLight.position.set(0, 10, -10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    scene.add(dirLight);

    // Voice memo visualizer
    const waveformContainer = document.getElementById('waveformContainer');
    const numBars = 30;
    const waveformBars = [];
    
    for (let i = 0; i < numBars; i++) {
      const bar = document.createElement('div');
      bar.className = 'waveform-bar';
      bar.style.height = '10px';
      waveformContainer.appendChild(bar);
      waveformBars.push(bar);
    }
    
    function animateWaveform() {
      if (!state.holding) return;
      
      if (analyser && dataArray) {
        // Use actual audio data
        analyser.getByteFrequencyData(dataArray);
        
        waveformBars.forEach((bar, i) => {
          const dataIndex = Math.floor(i * dataArray.length / waveformBars.length);
          const value = dataArray[dataIndex];
          const height = (value / 255) * 60 + 5;
          bar.style.height = height + 'px';
        });
      } else {
        // Fallback to random animation
        waveformBars.forEach((bar, i) => {
          const height = Math.random() * 50 + 10;
          bar.style.height = height + 'px';
        });
      }
      
      requestAnimationFrame(animateWaveform);
    }

    // Exit button functionality
    const exitButton = document.getElementById('exitButton');
    const exitWarning = document.getElementById('exitWarning');
    const cancelExit = document.getElementById('cancelExit');
    const proceedExit = document.getElementById('proceedExit');
    
    // Journal button functionality
    const journalButton = document.getElementById('journalButton');
    const journalModal = document.getElementById('journalModal');

    exitButton.addEventListener('click', (e) => {
      e.stopPropagation();
      exitWarning.classList.add('show');
      canvas.classList.add('hud-active');
      document.exitPointerLock();
    });

    cancelExit.addEventListener('click', (e) => {
      e.stopPropagation();
      exitWarning.classList.remove('show');
      canvas.classList.remove('hud-active');
    });

    proceedExit.addEventListener('click', (e) => {
      e.stopPropagation();
      const overlay = document.getElementById('fadeOverlay');
      overlay.classList.add('active');
      setTimeout(() => {
        window.location.href = '/';
      }, 500);
    });

    // Journal button functionality
    journalButton.addEventListener('click', (e) => {
      e.stopPropagation();
      journalModal.style.display = 'flex';
      canvas.classList.add('hud-active');
      document.exitPointerLock();
    });

    // Close journal modal
    const journalClose = document.querySelector('.journal-close');
    const journalBackdrop = document.querySelector('.journal-backdrop');
    
    journalClose.addEventListener('click', (e) => {
      e.stopPropagation();
      journalModal.style.display = 'none';
      canvas.classList.remove('hud-active');
    });

    journalBackdrop.addEventListener('click', (e) => {
      if (e.target === journalBackdrop) {
        journalModal.style.display = 'none';
        canvas.classList.remove('hud-active');
      }
    });

    // Close journal modal on ESC key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && journalModal.style.display === 'flex') {
        journalModal.style.display = 'none';
        canvas.classList.remove('hud-active');
      }
    });

    // Controls
    const keys = {};
    let mouseX = 0;
    let mouseY = 0;
    let pointerLocked = false;
    let autoMoveForward = false;

    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      
      if (e.code === 'KeyE' && state.nearDoor && !state.hudVisible && !isMobile) {
        state.hudVisible = true;
        document.getElementById('hud').classList.add('show');
        document.getElementById('doorPrompt').classList.remove('show');
        canvas.classList.add('hud-active');
        document.exitPointerLock();
      }
    });

    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    canvas.addEventListener('click', (e) => {
      if (!state.started) {
        state.started = true;
        document.getElementById('loading').style.display = 'none';
      }
      
      if (isMobile && state.started) {
        // On mobile, check if clicking near door
        if (state.nearDoor && !state.hudVisible) {
          state.hudVisible = true;
          document.getElementById('hud').classList.add('show');
          document.getElementById('doorPrompt').classList.remove('show');
          canvas.classList.add('hud-active');
        } else if (!state.hudVisible) {
          // Toggle auto-move forward on tap
          autoMoveForward = !autoMoveForward;
        }
      } else if (!isMobile && !state.hudVisible) {
        // Desktop: request pointer lock
        canvas.requestPointerLock();
      }
    });

    // Touch controls for mobile
    let touchStartX = 0;
    let touchStartY = 0;

    canvas.addEventListener('touchstart', (e) => {
      if (!state.started) {
        state.started = true;
        document.getElementById('loading').style.display = 'none';
      }
      
      if (e.touches.length > 0) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }
      
      // Check if near door
      if (state.nearDoor && !state.hudVisible) {
        state.hudVisible = true;
        document.getElementById('hud').classList.add('show');
        document.getElementById('doorPrompt').classList.remove('show');
        canvas.classList.add('hud-active');
      } else if (!state.hudVisible) {
        autoMoveForward = true;
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      if (!isMobile || state.hudVisible) return;
      e.preventDefault();
      
      if (e.touches.length > 0) {
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        
        const deltaX = touchX - touchStartX;
        const deltaY = touchY - touchStartY;
        
        // Rotate camera based on touch drag
        mouseX -= deltaX * 0.005;
        mouseY -= deltaY * 0.005;
        mouseY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, mouseY));
        
        touchStartX = touchX;
        touchStartY = touchY;
      }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      autoMoveForward = false;
    });

    document.addEventListener('pointerlockchange', () => {
      pointerLocked = document.pointerLockElement === canvas;
    });

    document.addEventListener('mousemove', (e) => {
      if (pointerLocked && !isMobile) {
        mouseX -= e.movementX * 0.002;
        mouseY -= e.movementY * 0.002;
        mouseY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, mouseY));
      }
    });

    // HUD
    const recordBtn = document.getElementById('recordBtn');
    const attemptCounter = document.getElementById('attemptCounter');
    const feedback = document.getElementById('feedback');
    const voiceVisualizer = document.getElementById('voiceMemoVisualizer');

    let mediaRecorder = null;
    let audioStream = null;
    let audioContext = null;
    let analyser = null;
    let dataArray = null;
    let audioEnabled = false;

    // Initialize audio recording
    async function initAudio() {
      try {
        audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(audioStream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 64;
        source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        audioEnabled = true;
        return true;
      } catch (err) {
        console.log('Audio not available, using timer mode:', err.message);
        audioEnabled = false;
        return false;
      }
    }

    recordBtn.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      if (state.holding) {
        // Stop recording
        handleRecordEnd();
      } else {
        // Start recording
        if (!audioStream && !audioEnabled) {
          const hasAudio = await initAudio();
          if (!hasAudio) {
            // Continue without audio - just use timer
            console.log('Recording without microphone - using timer only');
          }
        }
        
        state.holding = true;
        state.holdStart = Date.now();
        recordBtn.classList.add('holding');
        recordBtn.textContent = 'RECORDING... (Click to Stop)';
        voiceVisualizer.classList.add('active');
        animateWaveform();
        
        // Start media recorder if available
        if (audioStream) {
          try {
            mediaRecorder = new MediaRecorder(audioStream);
            mediaRecorder.start();
          } catch (err) {
            console.log('MediaRecorder not available');
          }
        }
      }
    });

    function handleRecordEnd() {
      if (!state.holding) return;

      const holdDuration = (Date.now() - state.holdStart) / 1000;
      state.holding = false;
      recordBtn.classList.remove('holding');
      recordBtn.textContent = 'Click to Record';
      voiceVisualizer.classList.remove('active');
      
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
      }

      if (holdDuration >= 2.0) {
        state.attempts++;
        attemptCounter.textContent = `Attempts: ${state.attempts}`;

        if (state.attempts >= state.targetAttempts) {
          state.exitAuthorized = true;
          showFeedback('COMPLIANCE ACCEPTED', true);
          setTimeout(() => {
            document.getElementById('hud').classList.remove('show');
            canvas.classList.remove('hud-active');
            state.hudVisible = false;
            openDoor();
          }, 1500);
        } else {
          showFeedback('NONCOMPLIANT — DOOR REMAINS LOCKED');
          setTimeout(() => {
            document.getElementById('hud').classList.remove('show');
            canvas.classList.remove('hud-active');
            state.hudVisible = false;
            resetToStart();
          }, 2000);
        }
      } else {
        showFeedback('RECORDING TOO SHORT — MINIMUM 2 SECONDS');
      }
    }

    function showFeedback(message, success = false) {
      feedback.textContent = message;
      feedback.className = 'gw-glass-dark';
      feedback.style.display = 'block';
      feedback.style.borderColor = success ? '#008F46' : '#a03030';
      feedback.style.color = success ? '#008F46' : '#ff6060';
      setTimeout(() => {
        feedback.style.display = 'none';
      }, 2000);
    }
    
    function openDoor() {
      const overlay = document.getElementById('fadeOverlay');
      overlay.classList.add('active');
      setTimeout(() => {
        window.location.href = '/';
      }, 1000);
    }

    function resetToStart() {
      camera.position.set(0, 1.6, 18);
      state.nearDoor = false;
      state.hallwaysPassed++;
      
      state.targetAttempts = Math.floor(Math.random() * 100) + 1;
      state.attempts = 0;
      attemptCounter.textContent = 'Attempts: 0';
      console.log('New target attempts:', state.targetAttempts);
    }
    
    // Collision
    function checkCollision(x, z, radius) {
      for (let wall of collisionWalls) {
        if (x >= wall.minX - radius && x <= wall.maxX + radius && 
            z >= wall.minZ - radius && z <= wall.maxZ + radius) {
          return true;
        }
      }
      return false;
    }
    
    // Movement
    const moveSpeed = 4;
    let bobPhase = 0;
    const playerRadius = 0.3;

    function updateMovement(delta) {
      if (!state.started || state.hudVisible) return;

      const velocity = new THREE.Vector3();
      
      if (isMobile) {
        // Mobile: auto-move forward when tapping
        if (autoMoveForward) {
          velocity.z = 1;
        }
      } else {
        // Desktop: WASD controls
        if (keys['KeyW']) velocity.z = 1;
        if (keys['KeyS']) velocity.z = -1;
        if (keys['KeyA']) velocity.x = -1;
        if (keys['KeyD']) velocity.x = 1;
      }

      if (velocity.length() > 0) {
        velocity.normalize();

        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        direction.y = 0;
        direction.normalize();

        const right = new THREE.Vector3();
        right.crossVectors(camera.up, direction).normalize();

        const moveZ = direction.clone().multiplyScalar(velocity.z * moveSpeed * delta);
        const moveX = right.clone().multiplyScalar(-velocity.x * moveSpeed * delta);
        
        const oldX = camera.position.x;
        const oldZ = camera.position.z;
        const newX = oldX + moveX.x + moveZ.x;
        const newZ = oldZ + moveX.z + moveZ.z;
        
        if (!checkCollision(newX, newZ, playerRadius)) {
          camera.position.x = newX;
          camera.position.z = newZ;
        } else {
          const tryX = oldX + moveX.x;
          if (!checkCollision(tryX, oldZ, playerRadius)) {
            camera.position.x = tryX;
          }
          
          const tryZ = oldZ + moveZ.z;
          if (!checkCollision(oldX, tryZ, playerRadius)) {
            camera.position.z = tryZ;
          }
        }
        
        bobPhase += delta * 6;
        camera.position.y = 1.6 + Math.sin(bobPhase) * 0.015;
      } else {
        camera.position.y += (1.6 - camera.position.y) * delta * 5;
      }

      camera.rotation.order = 'YXZ';
      camera.rotation.y = mouseX;
      camera.rotation.x = mouseY;

      // Check if near door
      if (doorMesh) {
        const doorPos = new THREE.Vector3();
        doorMesh.getWorldPosition(doorPos);
        const distance = camera.position.distanceTo(doorPos);
        
        if (distance < 3 && !state.nearDoor) {
          state.nearDoor = true;
          if (!isMobile) {
            document.getElementById('doorPrompt').classList.add('show');
          } else {
            document.getElementById('doorPrompt').textContent = 'Tap to approach the door';
            document.getElementById('doorPrompt').classList.add('show');
          }
        } else if (distance >= 3 && state.nearDoor) {
          state.nearDoor = false;
          document.getElementById('doorPrompt').classList.remove('show');
        }
      }
    }
    
    // Animation
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const time = clock.getElapsedTime();

      updateMovement(delta);

      // Panel flicker
      scene.traverse((obj) => {
        if (obj.userData.isPanel) {
          const flicker = Math.sin(time * 0.3) * 0.15 + (Math.random() - 0.5) * 0.05;
          obj.material.emissiveIntensity = obj.userData.baseIntensity + flicker;
        }
      });

      renderer.render(scene, camera);
    }
    
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    setTimeout(() => {
      document.getElementById('loading').textContent = 'CLICK TO START';
    }, 100);
  </script>
</body>
</html>