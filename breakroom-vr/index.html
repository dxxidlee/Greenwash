<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Greenwash Backroom</title>
  <style>
    @font-face {
      font-family: 'PPNeueMontreal';
      src: url('./fonts/PPNeueMontreal-Medium.otf') format('opentype');
      font-weight: 500;
      font-style: normal;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'PPNeueMontreal', sans-serif;
      overflow: hidden;
      background: #000;
    }
    
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
    }
    
    #hud {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(31, 41, 55, 0.9);
      backdrop-filter: blur(16px);
      padding: 40px 50px;
      border-radius: 12px;
      border: 1px solid rgba(0, 143, 70, 0.3);
      text-align: center;
      max-width: 600px;
      display: none;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(0, 143, 70, 0.2);
    }
    
    #hud.show {
      display: block;
    }
    
    .hud-title {
      color: #008F46;
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 24px;
      letter-spacing: 4px;
      text-transform: uppercase;
    }
    
    .hud-message {
      color: #00a653;
      font-size: 18px;
      line-height: 1.8;
      margin-bottom: 30px;
      font-weight: 300;
      font-style: italic;
    }
    
    .hud-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      margin-top: 24px;
    }
    
    .compliance-metrics {
      display: flex;
      justify-content: space-between;
      margin-bottom: 24px;
      padding: 16px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      border: 1px solid rgba(0, 143, 70, 0.2);
    }
    
    .metric-item {
      text-align: center;
    }
    
    .metric-label {
      color: #00a653;
      font-size: 10px;
      font-weight: 500;
      letter-spacing: 2px;
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    
    .metric-value {
      color: #008F46;
      font-size: 16px;
      font-weight: 700;
    }
    
    #recordBtn {
      background: #008F46;
      color: white;
      border: none;
      padding: 16px 40px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'PPNeueMontreal', sans-serif;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s;
      letter-spacing: 2px;
      text-transform: uppercase;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    
    #recordBtn:hover {
      background: #00a653;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }
    
    #recordBtn.holding {
      background: #005a2b;
      box-shadow: 0 0 20px rgba(0, 143, 70, 0.5);
      transform: scale(1.05);
    }
    
    #attemptCounter {
      color: #008F46;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    
    .system-status {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(31, 41, 55, 0.9);
      backdrop-filter: blur(16px);
      padding: 16px 20px;
      border-radius: 8px;
      border: 1px solid rgba(0, 143, 70, 0.3);
      z-index: 50;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }
    
    .status-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-size: 12px;
    }
    
    .status-item:last-child {
      margin-bottom: 0;
    }
    
    .status-label {
      color: #00a653;
      font-weight: 500;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    .status-value {
      color: #008F46;
      font-weight: 700;
    }
    
    .status-value.online {
      color: #00a653;
    }
    
    .status-value.warning {
      color: #ffa500;
    }
    
    #feedback {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(31, 41, 55, 0.95);
      backdrop-filter: blur(16px);
      color: #008F46;
      padding: 20px 30px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 500;
      display: none;
      z-index: 1000;
      border: 1px solid rgba(0, 143, 70, 0.3);
      letter-spacing: 2px;
      text-transform: uppercase;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }
    
    .progress-indicator {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(31, 41, 55, 0.9);
      backdrop-filter: blur(16px);
      padding: 12px 20px;
      border-radius: 8px;
      border: 1px solid rgba(0, 143, 70, 0.3);
      z-index: 50;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }
    
    .progress-bar {
      width: 200px;
      height: 4px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 8px;
    }
    
    .progress-fill {
      height: 100%;
      background: #008F46;
      border-radius: 2px;
      transition: width 0.3s ease;
      width: 0%;
    }
    
    #instructions {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(0, 143, 70, 0.8);
      font-size: 12px;
      text-align: center;
      z-index: 10;
      background: rgba(31, 41, 55, 0.9);
      backdrop-filter: blur(16px);
      padding: 12px 24px;
      border-radius: 8px;
      letter-spacing: 2px;
      text-transform: uppercase;
      border: 1px solid rgba(0, 143, 70, 0.3);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }
    
    #fadeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
      z-index: 2000;
    }
    
    #fadeOverlay.active {
      opacity: 1;
    }
    
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #008F46;
      font-size: 20px;
      z-index: 5000;
      letter-spacing: 2px;
    }
    
    #vignette {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 0%, rgba(0, 0, 0, 0.7) 100%);
      z-index: 1;
    }
    
    #homeButton {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 143, 70, 0.9);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'PPNeueMontreal', sans-serif;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 2px;
      text-transform: uppercase;
      z-index: 1000;
      transition: all 0.3s;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(16px);
    }
    
    #homeButton:hover {
      background: rgba(0, 143, 70, 1);
      transform: translateY(-1px);
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.6);
    }
  </style>
</head>
<body>
  <div id="loading">INITIALIZING COMPLIANCE TRAINING...</div>
  <canvas id="canvas"></canvas>
  <div id="vignette"></div>
  
  <button id="homeButton" onclick="window.location.href='/'">← BACK TO HOME</button>
  
  <!-- System Status Panel -->
  <div class="system-status">
    <div class="status-item">
      <span class="status-label">Chamber</span>
      <span class="status-value online">ONLINE</span>
    </div>
    <div class="status-item">
      <span class="status-label">Audio</span>
      <span class="status-value online">ACTIVE</span>
    </div>
    <div class="status-item">
      <span class="status-label">Compliance</span>
      <span class="status-value" id="complianceStatus">0%</span>
    </div>
  </div>
  
  <!-- Progress Indicator -->
  <div class="progress-indicator">
    <div style="color: #00a653; font-size: 12px; font-weight: 500; letter-spacing: 2px; text-transform: uppercase;">
      TRAINING PROGRESS
    </div>
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill"></div>
    </div>
  </div>
  
  <!-- Main HUD -->
  <div id="hud">
    <div class="hud-title">COMPLIANCE RECITAL</div>
    
    <!-- Compliance Metrics -->
    <div class="compliance-metrics">
      <div class="metric-item">
        <div class="metric-label">Attempts</div>
        <div class="metric-value" id="attemptCounter">0</div>
      </div>
      <div class="metric-item">
        <div class="metric-label">Target</div>
        <div class="metric-value" id="targetAttempts">1</div>
      </div>
      <div class="metric-item">
        <div class="metric-label">Status</div>
        <div class="metric-value" id="sessionStatus">STANDBY</div>
      </div>
    </div>
    
    <div class="hud-message">
      "Uniform green is policy. Compliance is a public good. I affirm my role in Greenwash."
    </div>
    
    <div class="hud-controls">
      <button id="recordBtn">HOLD TO RECORD</button>
    </div>
  </div>

  <div id="feedback"></div>
  <div id="instructions">CLICK TO START • WASD TO MOVE • MOUSE TO LOOK • ESC FOR INTERFACE</div>
  <div id="fadeOverlay"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    console.log('Starting Greenwash Backroom...');

    // Game state
    const state = {
      attempts: 0,
      targetAttempts: Math.floor(Math.random() * 100) + 1,
      exitAuthorized: false,
      hudVisible: false,
      holding: false,
      holdStart: 0,
      started: false
    };

    console.log('Target attempts:', state.targetAttempts);

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.FogExp2(0x0a1508, 0.08);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.6, 5);
    camera.lookAt(0, 1.6, 0);

    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.6;

    console.log('Renderer initialized');

    // Materials with more texture and grime
    const wallMaterial = new THREE.MeshStandardMaterial({
      color: 0xa8b8a0,
      roughness: 0.95,
      metalness: 0.02
    });

    const floorMaterial = new THREE.MeshStandardMaterial({
      color: 0x8a9a85,
      roughness: 0.9,
      metalness: 0.02
    });

    const columnMaterial = new THREE.MeshStandardMaterial({
      color: 0xb0c0a8,
      roughness: 0.92,
      metalness: 0.03
    });

    const ceilingMaterial = new THREE.MeshStandardMaterial({
      color: 0x95a590,
      roughness: 0.95,
      metalness: 0.01
    });

    const panelMaterial = new THREE.MeshStandardMaterial({
      color: 0xc0ffc0,
      emissive: 0x40a040,
      emissiveIntensity: 4,
      roughness: 0.3,
      metalness: 0.1
    });

    // Create endless backroom
    function createRoomSection(offsetX, offsetZ) {
      const group = new THREE.Group();
      const size = 20;

      // Floor
      const floorGeo = new THREE.PlaneGeometry(size, size, 10, 10);
      const floor = new THREE.Mesh(floorGeo, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(offsetX, 0, offsetZ);
      floor.receiveShadow = true;

      // Add slight random height variations for realism
      const posAttr = floorGeo.attributes.position;
      for (let i = 0; i < posAttr.count; i++) {
        posAttr.setZ(i, posAttr.getZ(i) + (Math.random() - 0.5) * 0.02);
      }
      floorGeo.computeVertexNormals();

      group.add(floor);

      // Ceiling with tiles
      const ceilingY = 2.7;
      const ceilingGeo = new THREE.PlaneGeometry(size, size);
      const ceiling = new THREE.Mesh(ceilingGeo, ceilingMaterial);
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.set(offsetX, ceilingY, offsetZ);
      ceiling.receiveShadow = true;
      group.add(ceiling);

      // Walls - create maze-like structure
      const wallHeight = 2.7;
      const wallConfigs = [
        // Create irregular corridors
        { x: -size/2, z: 0, w: 0.15, d: size, rot: 0 },
        { x: size/2, z: 0, w: 0.15, d: size, rot: 0 },
        { x: 0, z: -size/2, w: size, d: 0.15, rot: 0 },
        { x: 0, z: size/2, w: size, d: 0.15, rot: 0 },
      ];

      // Add some internal walls randomly
      for (let i = 0; i < 3; i++) {
        const rx = (Math.random() - 0.5) * size * 0.6;
        const rz = (Math.random() - 0.5) * size * 0.6;
        const isHorizontal = Math.random() > 0.5;

        wallConfigs.push({
          x: rx,
          z: rz,
          w: isHorizontal ? 8 : 0.15,
          d: isHorizontal ? 0.15 : 8,
          rot: 0
        });
      }

      wallConfigs.forEach(config => {
        const wall = new THREE.Mesh(
          new THREE.BoxGeometry(config.w, wallHeight, config.d),
          wallMaterial
        );
        wall.position.set(offsetX + config.x, wallHeight / 2, offsetZ + config.z);
        wall.castShadow = true;
        wall.receiveShadow = true;
        group.add(wall);
      });

      // Columns - irregular placement
      const columnPositions = [
        [-6, -6], [-6, 0], [-6, 6],
        [0, -6], [0, 6],
        [6, -6], [6, 0], [6, 6]
      ];

      columnPositions.forEach(([x, z]) => {
        const column = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, wallHeight, 0.5),
          columnMaterial
        );
        column.position.set(offsetX + x, wallHeight / 2, offsetZ + z);
        column.castShadow = true;
        column.receiveShadow = true;
        group.add(column);
      });

      // Ceiling panels - flickering effect will be added in animation
      const panelPositions = [
        [-7, -7], [-7, 0], [-7, 7],
        [0, -7], [0, 7],
        [7, -7], [7, 0], [7, 7]
      ];

      panelPositions.forEach(([x, z]) => {
        const panel = new THREE.Mesh(
          new THREE.BoxGeometry(1.8, 0.08, 0.9),
          panelMaterial.clone()
        );
        panel.position.set(offsetX + x, ceilingY - 0.15, offsetZ + z);
        panel.userData.isPanel = true;
        panel.userData.flickerOffset = Math.random() * 100;
        group.add(panel);
      });

      return group;
    }

    // Create 3x3 grid of rooms
    const rooms = [];
    for (let x = -1; x <= 1; x++) {
      for (let z = -1; z <= 1; z++) {
        const room = createRoomSection(x * 20, z * 20);
        rooms.push({
          mesh: room,
          gridX: x,
          gridZ: z
        });
        scene.add(room);
      }
    }
    console.log('Rooms created');

    // Lighting - fewer lights, more dramatic
    const ambientLight = new THREE.AmbientLight(0x304030, 0.15);
    scene.add(ambientLight);

    // Key lights positioned for dramatic effect
    const keyLight1 = new THREE.PointLight(0x60a060, 2, 20);
    keyLight1.position.set(0, 2.5, 0);
    keyLight1.castShadow = true;
    scene.add(keyLight1);

    const keyLight2 = new THREE.PointLight(0x50a050, 1.5, 18);
    keyLight2.position.set(8, 2.5, 8);
    scene.add(keyLight2);

    const keyLight3 = new THREE.PointLight(0x50a050, 1.5, 18);
    keyLight3.position.set(-8, 2.5, -8);
    scene.add(keyLight3);

    // Dim fill light
    const fillLight = new THREE.DirectionalLight(0x405040, 0.2);
    fillLight.position.set(5, 10, 5);
    scene.add(fillLight);

    console.log('Lighting added');

    // Controls
    const keys = {};
    let mouseX = 0;
    let mouseY = 0;
    let pointerLocked = false;

    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (e.code === 'Escape' && state.started) {
        state.hudVisible = !state.hudVisible;
        document.getElementById('hud').classList.toggle('show', state.hudVisible);
      }
    });

    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    canvas.addEventListener('click', () => {
      if (!state.started) {
        state.started = true;
        document.getElementById('loading').style.display = 'none';
        console.log('Game started');
      }
      canvas.requestPointerLock();
    });

    document.addEventListener('pointerlockchange', () => {
      pointerLocked = document.pointerLockElement === canvas;
    });

    document.addEventListener('mousemove', (e) => {
      if (pointerLocked) {
        mouseX -= e.movementX * 0.002;
        mouseY -= e.movementY * 0.002;
        mouseY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, mouseY));
      }
    });

    // HUD Controls
    const recordBtn = document.getElementById('recordBtn');
    const attemptCounter = document.getElementById('attemptCounter');
    const targetAttempts = document.getElementById('targetAttempts');
    const sessionStatus = document.getElementById('sessionStatus');
    const complianceStatus = document.getElementById('complianceStatus');
    const progressFill = document.getElementById('progressFill');
    const feedback = document.getElementById('feedback');

    // Update target attempts display
    targetAttempts.textContent = state.targetAttempts;

    recordBtn.addEventListener('mousedown', () => {
      state.holding = true;
      state.holdStart = Date.now();
      recordBtn.classList.add('holding');
      recordBtn.textContent = 'RECORDING...';
      sessionStatus.textContent = 'RECORDING';
    });

    function handleRecordEnd() {
      if (!state.holding) return;

      const holdDuration = (Date.now() - state.holdStart) / 1000;
      state.holding = false;
      recordBtn.classList.remove('holding');
      recordBtn.textContent = 'HOLD TO RECORD';
      sessionStatus.textContent = 'STANDBY';

      if (holdDuration >= 2.0) {
        state.attempts++;
        attemptCounter.textContent = state.attempts;
        
        // Update compliance percentage
        const compliancePercent = Math.min((state.attempts / state.targetAttempts) * 100, 100);
        complianceStatus.textContent = Math.round(compliancePercent) + '%';
        
        // Update progress bar
        progressFill.style.width = compliancePercent + '%';

        if (state.attempts >= state.targetAttempts) {
          state.exitAuthorized = true;
          sessionStatus.textContent = 'COMPLETE';
          showFeedback('EXIT AUTHORIZED', true);
          setTimeout(exitExperience, 2000);
        } else {
          showFeedback('NONCOMPLIANT — BEGIN AGAIN.');
        }
      } else {
        showFeedback('INSUFFICIENT RECORDING TIME');
      }
    }

    recordBtn.addEventListener('mouseup', handleRecordEnd);
    recordBtn.addEventListener('mouseleave', handleRecordEnd);

    function showFeedback(message, success = false) {
      feedback.textContent = message;
      feedback.style.display = 'block';
      feedback.style.borderColor = success ? '#008F46' : '#a03030';
      feedback.style.color = success ? '#008F46' : '#ff6060';
      setTimeout(() => {
        feedback.style.display = 'none';
      }, 3000);
    }
    
    function exitExperience() {
      const overlay = document.getElementById('fadeOverlay');
      overlay.classList.add('active');
      setTimeout(() => {
        window.location.href = '/';
      }, 1000);
    }

    // Movement with head bob
    const moveSpeed = 3.5;
    let bobPhase = 0;

    function updateMovement(delta) {
      if (!state.started) return;

      const velocity = new THREE.Vector3();
      let isMoving = false;

      if (keys['KeyW']) { velocity.z = -1; isMoving = true; }
      if (keys['KeyS']) { velocity.z = 1; isMoving = true; }
      if (keys['KeyA']) { velocity.x = -1; isMoving = true; }
      if (keys['KeyD']) { velocity.x = 1; isMoving = true; }

      if (velocity.length() > 0) {
        velocity.normalize();

        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        direction.y = 0;
        direction.normalize();

        const right = new THREE.Vector3();
        right.crossVectors(camera.up, direction).normalize();

        camera.position.add(direction.multiplyScalar(velocity.z * moveSpeed * delta));
        camera.position.add(right.multiplyScalar(-velocity.x * moveSpeed * delta));

        // Head bob
        bobPhase += delta * 8;
        camera.position.y = 1.6 + Math.sin(bobPhase) * 0.03;
      } else {
        // Return to normal height
        camera.position.y += (1.6 - camera.position.y) * delta * 5;
      }

      // Update camera rotation
      camera.rotation.order = 'YXZ';
      camera.rotation.y = mouseX;
      camera.rotation.x = mouseY;

      // Room recycling for endless effect
      const playerTileX = Math.round(camera.position.x / 20);
      const playerTileZ = Math.round(camera.position.z / 20);

      rooms.forEach(room => {
        const dx = room.gridX - playerTileX;
        const dz = room.gridZ - playerTileZ;

        if (Math.abs(dx) > 1 || Math.abs(dz) > 1) {
          // Recycle this room
          if (Math.abs(dx) > 1) {
            room.gridX = playerTileX + (dx > 0 ? 1 : -1);
          }
          if (Math.abs(dz) > 1) {
            room.gridZ = playerTileZ + (dz > 0 ? 1 : -1);
          }

          room.mesh.position.x = room.gridX * 20;
          room.mesh.position.z = room.gridZ * 20;
        }
      });
    }

    // Animation loop with flickering panels
    const clock = new THREE.Clock();
    let frameCount = 0;

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const time = clock.getElapsedTime();

      updateMovement(delta);

      // Flicker ceiling panels
      scene.traverse((obj) => {
        if (obj.userData.isPanel) {
          const flicker = Math.sin(time * 3 + obj.userData.flickerOffset) * 0.5 + 0.5;
          const noise = Math.random() * 0.1;
          obj.material.emissiveIntensity = 3 + flicker * 1.5 + noise;
        }
      });

      renderer.render(scene, camera);

      frameCount++;
      if (frameCount === 1) {
        console.log('First frame rendered!');
        document.getElementById('loading').textContent = 'CLICK TO START TRAINING';
        sessionStatus.textContent = 'READY';
      }
    }

    console.log('Starting animation loop...');
    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Show HUD after exploring
    setTimeout(() => {
      if (state.started) {
        state.hudVisible = true;
        document.getElementById('hud').classList.add('show');
        sessionStatus.textContent = 'ACTIVE';
      }
    }, 10000);

    console.log('Setup complete!');
  </script>
</body>
</html>
