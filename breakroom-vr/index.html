<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Greenwash Backroom</title>
  <style>
    @font-face {
      font-family: 'PPNeueMontreal';
      src: url('./fonts/PPNeueMontreal-Medium.otf') format('opentype');
      font-weight: 500;
      font-style: normal;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'PPNeueMontreal', sans-serif;
      overflow: hidden;
      background: #000;
    }
    
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
      filter: contrast(1.08) saturate(0.85) brightness(0.95);
    }
    
    #canvas.hud-active {
      pointer-events: none;
    }
    
    /* iOS-style glass pill used for hover labels */
    .gw-glass {
      color: #fff;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 9999px;
      padding: 8px 14px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(16px) saturate(180%);
      -webkit-backdrop-filter: blur(16px) saturate(180%);
      font-weight: 500;
    }

    /* Light silver glass for profile and circle hover labels */
    .gw-glass-light {
      color: #008F46;
      background: rgba(217, 217, 217, 0.3);
      border: 1px solid rgba(217, 217, 217, 0.4);
      border-radius: 9999px;
      padding: 8px 14px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(16px) saturate(180%);
      -webkit-backdrop-filter: blur(16px) saturate(180%);
      font-weight: 500;
    }

    /* Profile dropdown uses rectangular glass */
    .gw-glass-light.profile-dropdown {
      border-radius: 12px;
      padding: 12px 16px;
    }

    /* Dark glass for Ministry of Love and other dark modals */
    .gw-glass-dark {
      color: var(--gw-green);
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(0, 143, 70, 0.3);
      border-radius: 12px;
      padding: 12px 16px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(0, 143, 70, 0.2);
      backdrop-filter: blur(16px) saturate(180%);
      -webkit-backdrop-filter: blur(16px) saturate(180%);
      font-weight: 500;
    }

    :root { 
      --gw-green: #008F46; 
    }
    
    #hud {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 143, 70, 0.3);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 30px 40px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      text-align: center;
      max-width: 500px;
      display: none;
      z-index: 100;
      pointer-events: none;
    }
    
    #hud.show {
      display: block;
      pointer-events: auto;
    }
    
    #hud * {
      pointer-events: auto;
    }
    
    .hud-title {
      color: #FFFFFF;
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 20px;
      letter-spacing: 3px;
      text-transform: uppercase;
    }
    
    .hud-message {
      color: #FFFFFF;
      font-size: 16px;
      line-height: 1.8;
      margin-bottom: 25px;
      font-weight: 300;
    }
    
    .hud-controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }
    
    #recordBtn {
      background: rgba(0, 143, 70, 0.5);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 12px 30px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'PPNeueMontreal', sans-serif;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.3s;
      letter-spacing: 2px;
      text-transform: uppercase;
      user-select: none;
      -webkit-user-select: none;
    }
    
    #recordBtn:hover {
      background: rgba(0, 143, 70, 0.6);
    }
    
    #recordBtn.holding {
      background: rgba(0, 143, 70, 0.7);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
    }
    
    #voiceMemoVisualizer {
      display: none;
      width: 300px;
      height: 80px;
      margin: 15px auto;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 8px;
      padding: 10px;
      position: relative;
      overflow: hidden;
    }
    
    #voiceMemoVisualizer.active {
      display: block;
    }
    
    .waveform-container {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      gap: 3px;
    }
    
    .waveform-bar {
      width: 4px;
      background: #008F46;
      border-radius: 2px;
      transition: height 0.1s ease;
    }
    
    #attemptCounter {
      color: #FFFFFF;
      font-size: 12px;
      letter-spacing: 1px;
    }
    
    #feedback {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      color: #008F46;
      padding: 15px 30px;
      font-size: 14px;
      font-weight: 500;
      display: none;
      z-index: 1000;
      letter-spacing: 2px;
    }
    
    #feedback.gw-glass-dark {
      border-radius: 8px;
    }
    
    #instructions {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(0, 143, 70, 0.8);
      font-size: 11px;
      text-align: center;
      z-index: 10;
      letter-spacing: 2px;
      text-transform: uppercase;
      max-width: 90%;
    }
    
    .mobile-instructions {
      display: none;
    }
    
    .desktop-instructions {
      display: none;
    }
    
    #fadeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
      z-index: 2000;
    }
    
    #fadeOverlay.active {
      opacity: 1;
    }
    
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #008F46;
      font-size: 20px;
      z-index: 5000;
      letter-spacing: 2px;
    }
    
    #vignette {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 20%, rgba(0, 0, 0, 0.3) 70%, rgba(0, 0, 0, 0.6) 100%);
      z-index: 1;
      mix-blend-mode: multiply;
    }
    
    #filmGrain {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
      opacity: 0.08;
      background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDAiIGhlaWdodD0iMzAwIj48ZmlsdGVyIGlkPSJhIj48ZmVUdXJidWxlbmNlIGJhc2VGcmVxdWVuY3k9Ii43NSIgc3RpdGNoVGlsZXM9InN0aXRjaCIgdHlwZT0iZnJhY3RhbE5vaXNlIi8+PGZlQ29sb3JNYXRyaXggdHlwZT0ic2F0dXJhdGUiIHZhbHVlcz0iMCIvPjwvZmlsdGVyPjxwYXRoIGQ9Ik0wIDBoMzAwdjMwMEgweiIgZmlsdGVyPSJ1cmwoI2EpIiBvcGFjaXR5PSIuNSIvPjwvc3ZnPg==');
    }

    #doorPrompt {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #008F46;
      font-size: 18px;
      text-align: center;
      z-index: 50;
      padding: 20px 30px;
      display: none;
      letter-spacing: 2px;
    }
    
    #doorPrompt.show {
      display: block;
    }
    
    #exitButton {
      position: fixed;
      top: 16px;
      right: 16px;
      width: 48px;
      height: 48px;
      background: rgba(0, 143, 70, 0.3);
      border: 1px solid #FFFFFF;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 150;
      transition: all 0.3s;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    #exitButton:hover {
      background: rgba(0, 143, 70, 0.4);
    }
    
    #exitButton::before,
    #exitButton::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 2px;
      background: #ffffff;
      border-radius: 2px;
    }
    
    #exitButton::before {
      transform: rotate(45deg);
    }
    
    #exitButton::after {
      transform: rotate(-45deg);
    }
    
    #exitWarning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 143, 70, 0.3);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 30px 40px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      text-align: center;
      max-width: 450px;
      display: none;
      z-index: 200;
    }
    
    #exitWarning.show {
      display: block;
    }
    
    .warning-title {
      color: #FFFFFF;
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 20px;
      letter-spacing: 3px;
      text-transform: uppercase;
    }
    
    .warning-message {
      color: #FFFFFF;
      font-size: 16px;
      line-height: 1.8;
      margin-bottom: 25px;
      font-weight: 300;
    }
    
    .warning-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
    }
    
    .warning-btn {
      background: rgba(0, 143, 70, 0.2);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 10px 25px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'PPNeueMontreal', sans-serif;
      font-size: 11px;
      font-weight: 500;
      transition: all 0.3s;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    
    .warning-btn.proceed {
      background: rgba(0, 143, 70, 0.5);
      border-color: rgba(255, 255, 255, 0.5);
    }
    
    .warning-btn:hover {
      background: rgba(0, 143, 70, 0.4);
    }
    
    .warning-btn.proceed:hover {
      background: rgba(0, 143, 70, 0.6);
    }
    
  </style>
</head>
<body>
  <div id="loading">Loading...</div>
  <canvas id="canvas"></canvas>
  <div id="vignette"></div>
  <div id="filmGrain"></div>
  
  <div id="doorPrompt" class="gw-glass-dark">
    Press E to approach the door
  </div>
  
  <div id="exitButton" title="Exit Backroom"></div>
  
  <div id="exitWarning">
    <div class="warning-title">⚠ Warning</div>
    <div class="warning-message">
      Leaving the Backroom without completing the Compliance Recital will result in penalties. Your progress will not be saved.
    </div>
    <div class="warning-buttons">
      <button class="warning-btn cancel" id="cancelExit">Cancel</button>
      <button class="warning-btn proceed" id="proceedExit">Leave Anyway</button>
    </div>
  </div>
  
  <div id="hud">
    <div class="hud-title">Compliance Recital</div>
    <div class="hud-message">
      "Uniform green is policy. Compliance is a public good. I affirm my role in Greenwash."
    </div>
    <div class="hud-controls">
      <button id="recordBtn">Click to Record</button>
      <div id="voiceMemoVisualizer">
        <div class="waveform-container" id="waveformContainer"></div>
      </div>
      <div id="attemptCounter">Attempts: 0</div>
    </div>
  </div>

  <div id="feedback"></div>
  <div id="instructions" class="gw-glass-light">
    <span class="desktop-instructions">Click to start • WASD to move • Mouse to look • E to interact with door</span>
    <span class="mobile-instructions">Tap to start • Tap to move forward • Tap door to interact</span>
  </div>
  
  <div id="fadeOverlay"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // Detect mobile
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
    
    // Show appropriate instructions
    if (isMobile) {
      document.querySelector('.desktop-instructions').style.display = 'none';
      document.querySelector('.mobile-instructions').style.display = 'inline';
    } else {
      document.querySelector('.desktop-instructions').style.display = 'inline';
      document.querySelector('.mobile-instructions').style.display = 'none';
    }
    // Game state
    const state = {
      attempts: 0,
      targetAttempts: Math.floor(Math.random() * 100) + 1,
      exitAuthorized: false,
      hudVisible: false,
      holding: false,
      holdStart: 0,
      started: false,
      nearDoor: false,
      hallwaysPassed: 0
    };

    console.log('Target attempts:', state.targetAttempts);

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f140f);
    scene.fog = new THREE.Fog(0x2a3520, 3, 35);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.6, 0);

    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.5;
    renderer.physicallyCorrectLights = true;

    // Textures
    function createCarpetTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      for (let y = 0; y < 512; y += 4) {
        for (let x = 0; x < 512; x += 4) {
          const baseR = 74 + Math.random() * 20 - 10;
          const baseG = 72 + Math.random() * 18 - 9;
          const baseB = 53 + Math.random() * 15 - 7;
          ctx.fillStyle = `rgb(${baseR}, ${baseG}, ${baseB})`;
          ctx.fillRect(x, y, 4, 4);
        }
      }
      
      for (let i = 0; i < 4000; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const brightness = Math.random() * 40 - 20;
        ctx.fillStyle = `rgba(${80 + brightness}, ${75 + brightness}, ${55 + brightness}, 0.5)`;
        ctx.fillRect(x, y, 1, 2);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.encoding = THREE.sRGBEncoding;
      return texture;
    }
    
    function createWallTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      for (let y = 0; y < 512; y += 2) {
        for (let x = 0; x < 512; x += 2) {
          const baseR = 122 + Math.random() * 16 - 8;
          const baseG = 133 + Math.random() * 14 - 7;
          const baseB = 96 + Math.random() * 12 - 6;
          ctx.fillStyle = `rgb(${baseR}, ${baseG}, ${baseB})`;
          ctx.fillRect(x, y, 2, 2);
        }
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.encoding = THREE.sRGBEncoding;
      return texture;
    }
    
    function createCeilingTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      for (let y = 0; y < 512; y += 2) {
        for (let x = 0; x < 512; x += 2) {
          const baseR = 138 + Math.random() * 16 - 8;
          const baseG = 148 + Math.random() * 14 - 7;
          const baseB = 117 + Math.random() * 12 - 6;
          ctx.fillStyle = `rgb(${baseR}, ${baseG}, ${baseB})`;
          ctx.fillRect(x, y, 2, 2);
        }
      }
      
      ctx.globalAlpha = 0.25;
      for (let i = 0; i < 8; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const size = Math.random() * 50 + 30;
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
        gradient.addColorStop(0, '#5a5d48');
        gradient.addColorStop(1, 'rgba(90, 93, 72, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(x - size, y - size, size * 2, size * 2);
      }
      
      ctx.globalAlpha = 0.4;
      for (let i = 0; i < 1500; i++) {
        const brightness = Math.random() * 30 - 15;
        ctx.fillStyle = `rgb(${138 + brightness}, ${148 + brightness}, ${117 + brightness})`;
        ctx.fillRect(Math.random() * 512, Math.random() * 512, 1, 1);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.encoding = THREE.sRGBEncoding;
      return texture;
    }

    function createWoodTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Base wood color
      const gradient = ctx.createLinearGradient(0, 0, 512, 0);
      gradient.addColorStop(0, '#3a4a2a');
      gradient.addColorStop(0.5, '#445530');
      gradient.addColorStop(1, '#3a4a2a');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 512, 512);
      
      // Wood grain lines
      ctx.strokeStyle = 'rgba(30, 40, 20, 0.3)';
      for (let i = 0; i < 40; i++) {
        ctx.beginPath();
        ctx.lineWidth = Math.random() * 2 + 0.5;
        const y = Math.random() * 512;
        const curve = Math.random() * 20 - 10;
        ctx.moveTo(0, y);
        ctx.quadraticCurveTo(256, y + curve, 512, y);
        ctx.stroke();
      }
      
      // Wood texture detail
      for (let i = 0; i < 3000; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const brightness = Math.random() * 30 - 15;
        ctx.fillStyle = `rgba(${58 + brightness}, ${74 + brightness}, ${42 + brightness}, 0.4)`;
        ctx.fillRect(x, y, 1, 1);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.encoding = THREE.sRGBEncoding;
      return texture;
    }

    const carpetColor = createCarpetTexture();
    carpetColor.repeat.set(12, 12);
    
    const wallColor = createWallTexture();
    wallColor.repeat.set(2, 1);
    
    const ceilingColor = createCeilingTexture();
    ceilingColor.repeat.set(4, 4);

    const woodColor = createWoodTexture();
    woodColor.repeat.set(1, 3);

    // Materials
    const floorMaterial = new THREE.MeshStandardMaterial({
      map: carpetColor,
      roughness: 0.98,
      metalness: 0
    });
    
    const wallMaterial = new THREE.MeshStandardMaterial({
      map: wallColor,
      roughness: 0.88,
      metalness: 0
    });

    const ceilingMaterial = new THREE.MeshStandardMaterial({
      map: ceilingColor,
      roughness: 0.92,
      metalness: 0
    });

    const panelMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xb8c4a8,
      emissiveIntensity: 3.5,
      roughness: 0.25,
      metalness: 0.08
    });

    const doorMaterial = new THREE.MeshStandardMaterial({
      map: woodColor,
      roughness: 0.7,
      metalness: 0.05
    });

    // Collision system
    const collisionWalls = [];
    let doorMesh = null;
    
    function createCorridor() {
      const group = new THREE.Group();
      const width = 3;
      const height = 2.7;
      const length = 40;

      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(width, length),
        floorMaterial
      );
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      group.add(floor);

      // Ceiling with realistic drop ceiling tiles
      const tileSize = 0.6;
      const numTilesWidth = Math.ceil(width / tileSize);
      const numTilesLength = Math.ceil(length / tileSize);
      
      for (let x = 0; x < numTilesWidth; x++) {
        for (let z = 0; z < numTilesLength; z++) {
          const tile = new THREE.Mesh(
            new THREE.PlaneGeometry(tileSize - 0.01, tileSize - 0.01),
            ceilingMaterial.clone()
          );
          tile.rotation.x = Math.PI / 2;
          const posX = (x - numTilesWidth / 2) * tileSize + tileSize / 2;
          const posZ = (z - numTilesLength / 2) * tileSize + tileSize / 2;
          tile.position.set(posX, height - 0.01, posZ);
          tile.receiveShadow = true;
          group.add(tile);
        }
      }
      
      // Ceiling grid framework
      const gridMaterial = new THREE.MeshStandardMaterial({
        color: 0x4a5a3a,
        roughness: 0.7,
        metalness: 0.3
      });
      
      const gridThickness = 0.02;
      const gridDepth = 0.03;
      
      for (let z = -length / 2; z <= length / 2; z += tileSize) {
        const grid = new THREE.Mesh(
          new THREE.BoxGeometry(width, gridDepth, gridThickness),
          gridMaterial
        );
        grid.position.set(0, height - gridDepth / 2, z);
        grid.castShadow = true;
        group.add(grid);
      }
      
      for (let x = -width / 2; x <= width / 2; x += tileSize) {
        const grid = new THREE.Mesh(
          new THREE.BoxGeometry(gridThickness, gridDepth, length),
          gridMaterial
        );
        grid.position.set(x, height - gridDepth / 2, 0);
        grid.castShadow = true;
        group.add(grid);
      }
      
      // Walls
      const leftWall = new THREE.Mesh(
        new THREE.PlaneGeometry(length, height),
        wallMaterial
      );
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.set(-width / 2, height / 2, 0);
      leftWall.receiveShadow = true;
      leftWall.castShadow = true;
      group.add(leftWall);
      
      const rightWall = new THREE.Mesh(
        new THREE.PlaneGeometry(length, height),
        wallMaterial
      );
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.set(width / 2, height / 2, 0);
      rightWall.receiveShadow = true;
      rightWall.castShadow = true;
      group.add(rightWall);
      
      // Baseboards
      const baseboardMaterial = new THREE.MeshStandardMaterial({
        color: 0x3a3d28,
        roughness: 0.8,
        metalness: 0
      });
      
      const baseboardHeight = 0.08;
      const baseboardDepth = 0.02;
      
      const leftBaseboard = new THREE.Mesh(
        new THREE.BoxGeometry(length, baseboardHeight, baseboardDepth),
        baseboardMaterial
      );
      leftBaseboard.position.set(-width / 2 + baseboardDepth / 2, baseboardHeight / 2, 0);
      leftBaseboard.rotation.y = Math.PI / 2;
      leftBaseboard.receiveShadow = true;
      group.add(leftBaseboard);
      
      const rightBaseboard = new THREE.Mesh(
        new THREE.BoxGeometry(length, baseboardHeight, baseboardDepth),
        baseboardMaterial
      );
      rightBaseboard.position.set(width / 2 - baseboardDepth / 2, baseboardHeight / 2, 0);
      rightBaseboard.rotation.y = Math.PI / 2;
      rightBaseboard.receiveShadow = true;
      group.add(rightBaseboard);
      
      // Enhanced realistic door with panels
      const doorGroup = new THREE.Group();
      doorGroup.position.set(0, 1.1, -length / 2 + 0.05);
      
      // Main door body
      const door = new THREE.Mesh(
        new THREE.BoxGeometry(1.2, 2.2, 0.08),
        doorMaterial
      );
      door.castShadow = true;
      door.receiveShadow = true;
      door.userData.isDoor = true;
      doorGroup.add(door);
      doorMesh = door;
      
      // Door panels (recessed rectangles)
      const panelInset = 0.02;
      const panelMat = new THREE.MeshStandardMaterial({
        color: 0x2a3520,
        roughness: 0.8,
        metalness: 0
      });
      
      // Top panel
      const topPanel = new THREE.Mesh(
        new THREE.BoxGeometry(0.9, 0.8, panelInset),
        panelMat
      );
      topPanel.position.set(0, 0.5, -0.04);
      doorGroup.add(topPanel);
      
      // Bottom panel
      const bottomPanel = new THREE.Mesh(
        new THREE.BoxGeometry(0.9, 0.8, panelInset),
        panelMat
      );
      bottomPanel.position.set(0, -0.5, -0.04);
      doorGroup.add(bottomPanel);
      
      // Door handle
      const handleMat = new THREE.MeshStandardMaterial({
        color: 0x8a8a6a,
        roughness: 0.3,
        metalness: 0.8
      });
      
      const handleBase = new THREE.Mesh(
        new THREE.CylinderGeometry(0.02, 0.02, 0.1, 8),
        handleMat
      );
      handleBase.rotation.z = Math.PI / 2;
      handleBase.position.set(0.45, 0, 0.04);
      doorGroup.add(handleBase);
      
      const handleKnob = new THREE.Mesh(
        new THREE.SphereGeometry(0.04, 8, 8),
        handleMat
      );
      handleKnob.position.set(0.5, 0, 0.04);
      doorGroup.add(handleKnob);
      
      group.add(doorGroup);
      
      // Lighting
      for (let z = -length / 2 + 4; z < length / 2 - 4; z += 3.6) {
        // Recessed housing/frame
        const housingMaterial = new THREE.MeshStandardMaterial({
          color: 0x5a6550,
          roughness: 0.85,
          metalness: 0.1
        });
        
        const housing = new THREE.Mesh(
          new THREE.BoxGeometry(1.3, 0.08, 0.65),
          housingMaterial
        );
        housing.position.set(0, height - 0.08, z);
        housing.receiveShadow = true;
        group.add(housing);
        
        // Light diffuser panel
        const diffuserMaterial = new THREE.MeshStandardMaterial({
          color: 0xf5f5e8,
          emissive: 0xc8d4b8,
          emissiveIntensity: 4.5,
          roughness: 0.4,
          metalness: 0,
          opacity: 0.9,
          transparent: true
        });
        
        const panel = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 0.02, 0.6),
          diffuserMaterial
        );
        panel.position.set(0, height - 0.04, z);
        panel.userData.isPanel = true;
        panel.userData.baseIntensity = 4.5;
        panel.castShadow = false;
        group.add(panel);
        
        const light = new THREE.PointLight(0xc8d4b8, 6, 20);
        light.position.set(0, height - 0.1, z);
        light.decay = 2;
        light.castShadow = false;
        group.add(light);
      }
      
      // Collision walls
      collisionWalls.push({
        minX: -width / 2 - 0.1,
        maxX: -width / 2 + 0.1,
        minZ: -length / 2,
        maxZ: length / 2
      });
      
      collisionWalls.push({
        minX: width / 2 - 0.1,
        maxX: width / 2 + 0.1,
        minZ: -length / 2,
        maxZ: length / 2
      });
      
      collisionWalls.push({
        minX: -width / 2,
        maxX: width / 2,
        minZ: -length / 2 - 0.1,
        maxZ: -length / 2 + 0.1
      });

      return group;
    }

    // Create initial corridor
    const corridor = createCorridor();
    scene.add(corridor);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x6a7a5a, 0.4);
    scene.add(ambientLight);

    const hemiLight = new THREE.HemisphereLight(0x808a60, 0x4a5438, 0.5);
    scene.add(hemiLight);
    
    const dirLight = new THREE.DirectionalLight(0x7a8a6a, 0.3);
    dirLight.position.set(0, 10, -10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    scene.add(dirLight);

    // Voice memo visualizer
    const waveformContainer = document.getElementById('waveformContainer');
    const numBars = 30;
    const waveformBars = [];
    
    for (let i = 0; i < numBars; i++) {
      const bar = document.createElement('div');
      bar.className = 'waveform-bar';
      bar.style.height = '10px';
      waveformContainer.appendChild(bar);
      waveformBars.push(bar);
    }
    
    function animateWaveform() {
      if (!state.holding) return;
      
      if (analyser && dataArray) {
        // Use actual audio data
        analyser.getByteFrequencyData(dataArray);
        
        waveformBars.forEach((bar, i) => {
          const dataIndex = Math.floor(i * dataArray.length / waveformBars.length);
          const value = dataArray[dataIndex];
          const height = (value / 255) * 60 + 5;
          bar.style.height = height + 'px';
        });
      } else {
        // Fallback to random animation
        waveformBars.forEach((bar, i) => {
          const height = Math.random() * 50 + 10;
          bar.style.height = height + 'px';
        });
      }
      
      requestAnimationFrame(animateWaveform);
    }

    // Exit button functionality
    const exitButton = document.getElementById('exitButton');
    const exitWarning = document.getElementById('exitWarning');
    const cancelExit = document.getElementById('cancelExit');
    const proceedExit = document.getElementById('proceedExit');

    exitButton.addEventListener('click', (e) => {
      e.stopPropagation();
      exitWarning.classList.add('show');
      canvas.classList.add('hud-active');
      document.exitPointerLock();
    });

    cancelExit.addEventListener('click', (e) => {
      e.stopPropagation();
      exitWarning.classList.remove('show');
      canvas.classList.remove('hud-active');
    });

    proceedExit.addEventListener('click', (e) => {
      e.stopPropagation();
      const overlay = document.getElementById('fadeOverlay');
      overlay.classList.add('active');
      setTimeout(() => {
        window.location.href = '/';
      }, 500);
    });

    // Controls
    const keys = {};
    let mouseX = 0;
    let mouseY = 0;
    let pointerLocked = false;
    let autoMoveForward = false;

    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      
      if (e.code === 'KeyE' && state.nearDoor && !state.hudVisible && !isMobile) {
        state.hudVisible = true;
        document.getElementById('hud').classList.add('show');
        document.getElementById('doorPrompt').classList.remove('show');
        canvas.classList.add('hud-active');
        document.exitPointerLock();
      }
    });

    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    canvas.addEventListener('click', (e) => {
      if (!state.started) {
        state.started = true;
        document.getElementById('loading').style.display = 'none';
      }
      
      if (isMobile && state.started) {
        // On mobile, check if clicking near door
        if (state.nearDoor && !state.hudVisible) {
          state.hudVisible = true;
          document.getElementById('hud').classList.add('show');
          document.getElementById('doorPrompt').classList.remove('show');
          canvas.classList.add('hud-active');
        } else if (!state.hudVisible) {
          // Toggle auto-move forward on tap
          autoMoveForward = !autoMoveForward;
        }
      } else if (!isMobile && !state.hudVisible) {
        // Desktop: request pointer lock
        canvas.requestPointerLock();
      }
    });

    // Touch controls for mobile
    let touchStartX = 0;
    let touchStartY = 0;

    canvas.addEventListener('touchstart', (e) => {
      if (!state.started) {
        state.started = true;
        document.getElementById('loading').style.display = 'none';
      }
      
      if (e.touches.length > 0) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }
      
      // Check if near door
      if (state.nearDoor && !state.hudVisible) {
        state.hudVisible = true;
        document.getElementById('hud').classList.add('show');
        document.getElementById('doorPrompt').classList.remove('show');
        canvas.classList.add('hud-active');
      } else if (!state.hudVisible) {
        autoMoveForward = true;
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      if (!isMobile || state.hudVisible) return;
      e.preventDefault();
      
      if (e.touches.length > 0) {
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        
        const deltaX = touchX - touchStartX;
        const deltaY = touchY - touchStartY;
        
        // Rotate camera based on touch drag
        mouseX -= deltaX * 0.005;
        mouseY -= deltaY * 0.005;
        mouseY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, mouseY));
        
        touchStartX = touchX;
        touchStartY = touchY;
      }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      autoMoveForward = false;
    });

    document.addEventListener('pointerlockchange', () => {
      pointerLocked = document.pointerLockElement === canvas;
    });

    document.addEventListener('mousemove', (e) => {
      if (pointerLocked && !isMobile) {
        mouseX -= e.movementX * 0.002;
        mouseY -= e.movementY * 0.002;
        mouseY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, mouseY));
      }
    });

    // HUD
    const recordBtn = document.getElementById('recordBtn');
    const attemptCounter = document.getElementById('attemptCounter');
    const feedback = document.getElementById('feedback');
    const voiceVisualizer = document.getElementById('voiceMemoVisualizer');

    let mediaRecorder = null;
    let audioStream = null;
    let audioContext = null;
    let analyser = null;
    let dataArray = null;
    let audioEnabled = false;

    // Initialize audio recording
    async function initAudio() {
      try {
        audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(audioStream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 64;
        source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        audioEnabled = true;
        return true;
      } catch (err) {
        console.log('Audio not available, using timer mode:', err.message);
        audioEnabled = false;
        return false;
      }
    }

    recordBtn.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      if (state.holding) {
        // Stop recording
        handleRecordEnd();
      } else {
        // Start recording
        if (!audioStream && !audioEnabled) {
          const hasAudio = await initAudio();
          if (!hasAudio) {
            // Continue without audio - just use timer
            console.log('Recording without microphone - using timer only');
          }
        }
        
        state.holding = true;
        state.holdStart = Date.now();
        recordBtn.classList.add('holding');
        recordBtn.textContent = 'RECORDING... (Click to Stop)';
        voiceVisualizer.classList.add('active');
        animateWaveform();
        
        // Start media recorder if available
        if (audioStream) {
          try {
            mediaRecorder = new MediaRecorder(audioStream);
            mediaRecorder.start();
          } catch (err) {
            console.log('MediaRecorder not available');
          }
        }
      }
    });

    function handleRecordEnd() {
      if (!state.holding) return;

      const holdDuration = (Date.now() - state.holdStart) / 1000;
      state.holding = false;
      recordBtn.classList.remove('holding');
      recordBtn.textContent = 'Click to Record';
      voiceVisualizer.classList.remove('active');
      
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
      }

      if (holdDuration >= 2.0) {
        state.attempts++;
        attemptCounter.textContent = `Attempts: ${state.attempts}`;

        if (state.attempts >= state.targetAttempts) {
          state.exitAuthorized = true;
          showFeedback('COMPLIANCE ACCEPTED', true);
          setTimeout(() => {
            document.getElementById('hud').classList.remove('show');
            canvas.classList.remove('hud-active');
            state.hudVisible = false;
            openDoor();
          }, 1500);
        } else {
          showFeedback('NONCOMPLIANT — DOOR REMAINS LOCKED');
          setTimeout(() => {
            document.getElementById('hud').classList.remove('show');
            canvas.classList.remove('hud-active');
            state.hudVisible = false;
            resetToStart();
          }, 2000);
        }
      } else {
        showFeedback('RECORDING TOO SHORT — MINIMUM 2 SECONDS');
      }
    }

    function showFeedback(message, success = false) {
      feedback.textContent = message;
      feedback.className = 'gw-glass-dark';
      feedback.style.display = 'block';
      feedback.style.borderColor = success ? '#008F46' : '#a03030';
      feedback.style.color = success ? '#008F46' : '#ff6060';
      setTimeout(() => {
        feedback.style.display = 'none';
      }, 2000);
    }
    
    function openDoor() {
      const overlay = document.getElementById('fadeOverlay');
      overlay.classList.add('active');
      setTimeout(() => {
        window.location.href = '/';
      }, 1000);
    }

    function resetToStart() {
      camera.position.set(0, 1.6, 18);
      state.nearDoor = false;
      state.hallwaysPassed++;
      
      state.targetAttempts = Math.floor(Math.random() * 100) + 1;
      state.attempts = 0;
      attemptCounter.textContent = 'Attempts: 0';
      console.log('New target attempts:', state.targetAttempts);
    }
    
    // Collision
    function checkCollision(x, z, radius) {
      for (let wall of collisionWalls) {
        if (x >= wall.minX - radius && x <= wall.maxX + radius && 
            z >= wall.minZ - radius && z <= wall.maxZ + radius) {
          return true;
        }
      }
      return false;
    }
    
    // Movement
    const moveSpeed = 4;
    let bobPhase = 0;
    const playerRadius = 0.3;

    function updateMovement(delta) {
      if (!state.started || state.hudVisible) return;

      const velocity = new THREE.Vector3();
      
      if (isMobile) {
        // Mobile: auto-move forward when tapping
        if (autoMoveForward) {
          velocity.z = 1;
        }
      } else {
        // Desktop: WASD controls
        if (keys['KeyW']) velocity.z = 1;
        if (keys['KeyS']) velocity.z = -1;
        if (keys['KeyA']) velocity.x = -1;
        if (keys['KeyD']) velocity.x = 1;
      }

      if (velocity.length() > 0) {
        velocity.normalize();

        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        direction.y = 0;
        direction.normalize();

        const right = new THREE.Vector3();
        right.crossVectors(camera.up, direction).normalize();

        const moveZ = direction.clone().multiplyScalar(velocity.z * moveSpeed * delta);
        const moveX = right.clone().multiplyScalar(-velocity.x * moveSpeed * delta);
        
        const oldX = camera.position.x;
        const oldZ = camera.position.z;
        const newX = oldX + moveX.x + moveZ.x;
        const newZ = oldZ + moveX.z + moveZ.z;
        
        if (!checkCollision(newX, newZ, playerRadius)) {
          camera.position.x = newX;
          camera.position.z = newZ;
        } else {
          const tryX = oldX + moveX.x;
          if (!checkCollision(tryX, oldZ, playerRadius)) {
            camera.position.x = tryX;
          }
          
          const tryZ = oldZ + moveZ.z;
          if (!checkCollision(oldX, tryZ, playerRadius)) {
            camera.position.z = tryZ;
          }
        }
        
        bobPhase += delta * 6;
        camera.position.y = 1.6 + Math.sin(bobPhase) * 0.015;
      } else {
        camera.position.y += (1.6 - camera.position.y) * delta * 5;
      }

      camera.rotation.order = 'YXZ';
      camera.rotation.y = mouseX;
      camera.rotation.x = mouseY;

      // Check if near door
      if (doorMesh) {
        const doorPos = new THREE.Vector3();
        doorMesh.getWorldPosition(doorPos);
        const distance = camera.position.distanceTo(doorPos);
        
        if (distance < 3 && !state.nearDoor) {
          state.nearDoor = true;
          if (!isMobile) {
            document.getElementById('doorPrompt').classList.add('show');
          } else {
            document.getElementById('doorPrompt').textContent = 'Tap to approach the door';
            document.getElementById('doorPrompt').classList.add('show');
          }
        } else if (distance >= 3 && state.nearDoor) {
          state.nearDoor = false;
          document.getElementById('doorPrompt').classList.remove('show');
        }
      }
    }
    
    // Animation
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const time = clock.getElapsedTime();

      updateMovement(delta);

      // Panel flicker
      scene.traverse((obj) => {
        if (obj.userData.isPanel) {
          const flicker = Math.sin(time * 0.3) * 0.15 + (Math.random() - 0.5) * 0.05;
          obj.material.emissiveIntensity = obj.userData.baseIntensity + flicker;
        }
      });

      renderer.render(scene, camera);
    }
    
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    setTimeout(() => {
      document.getElementById('loading').textContent = 'CLICK TO START';
    }, 100);
  </script>
</body>
</html>