<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Greenwash Backroom</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Space Grotesk', sans-serif;
      overflow: hidden;
      background: #000;
    }
    
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
    }
    
    #hud {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 20, 10, 0.85);
      backdrop-filter: blur(10px);
      padding: 30px 40px;
      border-radius: 2px;
      border: 1px solid rgba(0, 143, 70, 0.3);
      text-align: center;
      max-width: 500px;
      display: none;
      z-index: 100;
      box-shadow: 0 0 30px rgba(0, 143, 70, 0.2);
    }
    
    #hud.show {
      display: block;
    }
    
    .hud-title {
      color: #008F46;
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 20px;
      letter-spacing: 3px;
      text-transform: uppercase;
    }
    
    .hud-message {
      color: #00a653;
      font-size: 16px;
      line-height: 1.8;
      margin-bottom: 25px;
      font-weight: 300;
    }
    
    .hud-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }
    
    #recordBtn {
      background: #008F46;
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 2px;
      cursor: pointer;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.3s;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    #recordBtn:hover {
      background: #00a653;
    }
    
    #recordBtn.holding {
      background: #005a2b;
      box-shadow: 0 0 20px rgba(0, 143, 70, 0.5);
    }
    
    #attemptCounter {
      color: #008F46;
      font-size: 12px;
      letter-spacing: 1px;
    }
    
    #feedback {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      color: #008F46;
      padding: 15px 30px;
      border-radius: 2px;
      font-size: 14px;
      font-weight: 500;
      display: none;
      z-index: 1000;
      border: 1px solid #008F46;
      letter-spacing: 2px;
    }
    
    #instructions {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(0, 143, 70, 0.6);
      font-size: 11px;
      text-align: center;
      z-index: 10;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      border-radius: 2px;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    #fadeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
      z-index: 2000;
    }
    
    #fadeOverlay.active {
      opacity: 1;
    }

    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #008F46;
      font-size: 20px;
      z-index: 5000;
      letter-spacing: 2px;
    }
  </style>
</head>
<body>
  <div id="loading">INITIALIZING...</div>
  <canvas id="canvas"></canvas>
  
  <div id="hud">
    <div class="hud-title">Compliance Recital</div>
    <div class="hud-message">
      "Uniform green is policy. Compliance is a public good. I affirm my role in Greenwash."
    </div>
    <div class="hud-controls">
      <button id="recordBtn">Hold to Record</button>
      <div id="attemptCounter">Attempts: 0</div>
    </div>
  </div>
  
  <div id="feedback"></div>
  <div id="instructions">Click to start • WASD to move • Mouse to look • ESC for interface</div>
  <div id="fadeOverlay"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    console.log('Starting Greenwash Backroom...');

    // Game state
    const state = {
      attempts: 0,
      targetAttempts: Math.floor(Math.random() * 100) + 1,
      exitAuthorized: false,
      hudVisible: false,
      holding: false,
      holdStart: 0,
      started: false
    };
    
    console.log('Target attempts:', state.targetAttempts);

    // Scene setup with proper PBR settings
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0f0a);
    scene.fog = new THREE.Fog(0x3a4a2a, 2, 35);
    
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.6, 0);
    camera.lookAt(0, 1.6, -10);
    
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ 
      canvas: canvas, 
      antialias: true,
      powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    // Enable shadows with soft quality
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // PBR rendering settings - CRITICAL for realism
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.7;
    renderer.physicallyCorrectLights = true;
    
    console.log('Renderer initialized with PBR settings');

    // Create highly detailed PBR textures
    function createDetailedCarpetTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 1024;
      const ctx = canvas.getContext('2d');
      
      // Base olive-tan carpet color
      const gradient = ctx.createLinearGradient(0, 0, 1024, 1024);
      gradient.addColorStop(0, '#726b4a');
      gradient.addColorStop(0.5, '#6b6445');
      gradient.addColorStop(1, '#655e40');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 1024, 1024);
      
      // Carpet fiber texture - very dense
      for (let i = 0; i < 30000; i++) {
        const x = Math.random() * 1024;
        const y = Math.random() * 1024;
        const brightness = Math.random() * 35 - 18;
        const alpha = 0.3 + Math.random() * 0.4;
        ctx.fillStyle = `rgba(${114 + brightness}, ${107 + brightness}, ${74 + brightness}, ${alpha})`;
        ctx.fillRect(x, y, 1, Math.random() * 2);
      }
      
      // Add directional wear patterns
      ctx.globalAlpha = 0.15;
      for (let i = 0; i < 40; i++) {
        const x = Math.random() * 1024;
        const y = Math.random() * 1024;
        ctx.fillStyle = '#3a3525';
        ctx.fillRect(x, y, Math.random() * 150 + 50, Math.random() * 30 + 10);
      }
      
      // Add random dirt spots
      ctx.globalAlpha = 0.2;
      for (let i = 0; i < 50; i++) {
        const x = Math.random() * 1024;
        const y = Math.random() * 1024;
        const size = Math.random() * 20 + 5;
        ctx.fillStyle = '#2a2515';
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.encoding = THREE.sRGBEncoding;
      return texture;
    }
    
    function createCarpetNormalMap() {
      const canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 1024;
      const ctx = canvas.getContext('2d');
      
      // Base normal color (pointing up)
      ctx.fillStyle = '#8080ff';
      ctx.fillRect(0, 0, 1024, 1024);
      
      // Add subtle fiber bumps
      for (let i = 0; i < 15000; i++) {
        const x = Math.random() * 1024;
        const y = Math.random() * 1024;
        const variation = Math.random() * 60 - 30;
        ctx.fillStyle = `rgb(${128 + variation}, ${128 + variation}, ${200 + Math.random() * 40})`;
        ctx.fillRect(x, y, 1, 2);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.encoding = THREE.LinearEncoding;
      return texture;
    }
    
    function createCarpetRoughnessMap() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Base roughness (carpet is very rough)
      ctx.fillStyle = '#e0e0e0';
      ctx.fillRect(0, 0, 512, 512);
      
      // Variation in roughness
      for (let i = 0; i < 8000; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const darkness = Math.random() * 40;
        ctx.fillStyle = `rgb(${224 - darkness}, ${224 - darkness}, ${224 - darkness})`;
        ctx.fillRect(x, y, 2, 2);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.encoding = THREE.LinearEncoding;
      return texture;
    }
    
    function createWallTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 1024;
      const ctx = canvas.getContext('2d');
      
      // Yellowish-green institutional wall color
      ctx.fillStyle = '#8a9468';
      ctx.fillRect(0, 0, 1024, 1024);
      
      // Paint texture with subtle variations
      for (let i = 0; i < 20000; i++) {
        const x = Math.random() * 1024;
        const y = Math.random() * 1024;
        const brightness = Math.random() * 30 - 15;
        const alpha = 0.3 + Math.random() * 0.3;
        ctx.fillStyle = `rgba(${138 + brightness}, ${148 + brightness}, ${104 + brightness}, ${alpha})`;
        ctx.fillRect(x, y, 2, 2);
      }
      
      // Vertical streaks from moisture/age
      ctx.globalAlpha = 0.12;
      for (let i = 0; i < 50; i++) {
        ctx.fillStyle = '#5a6448';
        const x = Math.random() * 1024;
        ctx.fillRect(x, 0, Math.random() * 3 + 1, 1024);
      }
      
      // Dirt accumulation near floor
      const dirtGradient = ctx.createLinearGradient(0, 800, 0, 1024);
      dirtGradient.addColorStop(0, 'rgba(40, 45, 30, 0)');
      dirtGradient.addColorStop(1, 'rgba(40, 45, 30, 0.2)');
      ctx.fillStyle = dirtGradient;
      ctx.fillRect(0, 800, 1024, 224);
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.encoding = THREE.sRGBEncoding;
      return texture;
    }
    
    function createWallNormalMap() {
      const canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 1024;
      const ctx = canvas.getContext('2d');
      
      ctx.fillStyle = '#8080ff';
      ctx.fillRect(0, 0, 1024, 1024);
      
      // Paint texture bumps
      for (let i = 0; i < 10000; i++) {
        const x = Math.random() * 1024;
        const y = Math.random() * 1024;
        const variation = Math.random() * 30 - 15;
        ctx.fillStyle = `rgb(${128 + variation}, ${128 + variation}, ${220 + Math.random() * 20})`;
        ctx.fillRect(x, y, 2, 2);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.encoding = THREE.LinearEncoding;
      return texture;
    }
    
    function createCeilingTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Aged ceiling tile color
      ctx.fillStyle = '#9aa684';
      ctx.fillRect(0, 0, 512, 512);
      
      // Water stains and age spots
      ctx.globalAlpha = 0.3;
      for (let i = 0; i < 30; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const size = Math.random() * 80 + 30;
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
        gradient.addColorStop(0, '#6a6a50');
        gradient.addColorStop(1, 'rgba(106, 106, 80, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(x - size, y - size, size * 2, size * 2);
      }
      
      // Fine texture
      ctx.globalAlpha = 0.5;
      for (let i = 0; i < 8000; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const brightness = Math.random() * 40 - 20;
        ctx.fillStyle = `rgb(${154 + brightness}, ${166 + brightness}, ${132 + brightness})`;
        ctx.fillRect(x, y, 1, 1);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.encoding = THREE.sRGBEncoding;
      return texture;
    }
    
    function createAOMap() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Base white
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, 512, 512);
      
      // Darken corners and edges
      const gradient = ctx.createRadialGradient(256, 256, 50, 256, 256, 300);
      gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 512, 512);
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.encoding = THREE.LinearEncoding;
      return texture;
    }
    
    // Generate all textures
    const carpetColor = createDetailedCarpetTexture();
    carpetColor.wrapS = carpetColor.wrapT = THREE.RepeatWrapping;
    carpetColor.repeat.set(10, 10);
    
    const carpetNormal = createCarpetNormalMap();
    carpetNormal.wrapS = carpetNormal.wrapT = THREE.RepeatWrapping;
    carpetNormal.repeat.set(10, 10);
    
    const carpetRoughness = createCarpetRoughnessMap();
    carpetRoughness.wrapS = carpetRoughness.wrapT = THREE.RepeatWrapping;
    carpetRoughness.repeat.set(10, 10);
    
    const wallColor = createWallTexture();
    wallColor.wrapS = wallColor.wrapT = THREE.RepeatWrapping;
    wallColor.repeat.set(4, 2);
    
    const wallNormal = createWallNormalMap();
    wallNormal.wrapS = wallNormal.wrapT = THREE.RepeatWrapping;
    wallNormal.repeat.set(4, 2);
    
    const ceilingColor = createCeilingTexture();
    ceilingColor.wrapS = ceilingColor.wrapT = THREE.RepeatWrapping;
    ceilingColor.repeat.set(8, 8);
    
    const aoMap = createAOMap();
    
    console.log('PBR textures generated');
    
    // PBR Materials with physically accurate properties
    const floorMaterial = new THREE.MeshStandardMaterial({
      map: carpetColor,
      normalMap: carpetNormal,
      normalScale: new THREE.Vector2(0.3, 0.3),
      roughnessMap: carpetRoughness,
      roughness: 0.95,
      metalness: 0,
      aoMap: aoMap,
      aoMapIntensity: 1.2
    });
    
    const wallMaterial = new THREE.MeshStandardMaterial({
      map: wallColor,
      normalMap: wallNormal,
      normalScale: new THREE.Vector2(0.2, 0.2),
      roughness: 0.85,
      metalness: 0,
      aoMap: aoMap,
      aoMapIntensity: 1.0
    });
    
    const ceilingMaterial = new THREE.MeshStandardMaterial({
      map: ceilingColor,
      roughness: 0.9,
      metalness: 0,
      aoMap: aoMap,
      aoMapIntensity: 0.8
    });
    
    const panelMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xc8d4b8,
      emissiveIntensity: 2.5,
      roughness: 0.3,
      metalness: 0.05
    });

    // Collision system
    const collisionWalls = [];
    
    function createCorridorSection(offsetZ) {
      const group = new THREE.Group();
      const width = 3;
      const height = 2.7;
      const length = 20;
      
      // Floor with proper UV mapping
      const floorGeo = new THREE.PlaneGeometry(width, length, 20, 20);
      const floor = new THREE.Mesh(floorGeo, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(0, 0, offsetZ);
      floor.receiveShadow = true;
      
      // Add second UV channel for AO
      const uvs = floorGeo.attributes.uv.array;
      floorGeo.setAttribute('uv2', new THREE.BufferAttribute(uvs, 2));
      
      group.add(floor);
      
      // Ceiling
      const ceilingGeo = new THREE.PlaneGeometry(width, length, 10, 10);
      const ceiling = new THREE.Mesh(ceilingGeo, ceilingMaterial);
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.set(0, height, offsetZ);
      ceiling.receiveShadow = true;
      
      const ceilingUvs = ceilingGeo.attributes.uv.array;
      ceilingGeo.setAttribute('uv2', new THREE.BufferAttribute(ceilingUvs, 2));
      
      group.add(ceiling);
      
      // Left wall
      const leftWallGeo = new THREE.PlaneGeometry(length, height, 10, 10);
      const leftWall = new THREE.Mesh(leftWallGeo, wallMaterial);
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.set(-width / 2, height / 2, offsetZ);
      leftWall.receiveShadow = true;
      leftWall.castShadow = true;
      
      const leftUvs = leftWallGeo.attributes.uv.array;
      leftWallGeo.setAttribute('uv2', new THREE.BufferAttribute(leftUvs, 2));
      
      group.add(leftWall);
      
      // Right wall
      const rightWallGeo = new THREE.PlaneGeometry(length, height, 10, 10);
      const rightWall = new THREE.Mesh(rightWallGeo, wallMaterial);
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.set(width / 2, height / 2, offsetZ);
      rightWall.receiveShadow = true;
      rightWall.castShadow = true;
      
      const rightUvs = rightWallGeo.attributes.uv.array;
      rightWallGeo.setAttribute('uv2', new THREE.BufferAttribute(rightUvs, 2));
      
      group.add(rightWall);
      
      // Collision boundaries
      collisionWalls.push({
        minX: -width / 2 - 0.1,
        maxX: -width / 2 + 0.1,
        minZ: offsetZ - length / 2,
        maxZ: offsetZ + length / 2
      });
      
      collisionWalls.push({
        minX: width / 2 - 0.1,
        maxX: width / 2 + 0.1,
        minZ: offsetZ - length / 2,
        maxZ: offsetZ + length / 2
      });
      
      // Ceiling panels with realistic lighting
      for (let z = -length / 2 + 3; z < length / 2; z += 4) {
        const panel = new THREE.Mesh(
          new THREE.BoxGeometry(1.3, 0.04, 0.65),
          panelMaterial.clone()
        );
        panel.position.set(0, height - 0.04, offsetZ + z);
        panel.userData.isPanel = true;
        panel.userData.baseIntensity = 2.5 + Math.random() * 0.4;
        panel.userData.flickerPhase = Math.random() * Math.PI * 2;
        panel.castShadow = false;
        group.add(panel);
        
        // Physically accurate light
        const light = new THREE.RectAreaLight(0xc8d4b8, 4, 1.3, 0.65);
        light.position.set(0, height - 0.15, offsetZ + z);
        light.rotation.x = Math.PI;
        group.add(light);
      }
      
      return group;
    }
    
    // Create corridor segments
    const corridors = [];
    for (let i = -3; i <= 3; i++) {
      const corridor = createCorridorSection(i * 20);
      corridors.push({
        mesh: corridor,
        index: i
      });
      scene.add(corridor);
    }
    
    console.log('Corridors created with PBR materials');
    console.log('Collision walls:', collisionWalls.length);
    
    // Realistic lighting setup
    const ambientLight = new THREE.AmbientLight(0x8a9a6a, 0.4);
    scene.add(ambientLight);
    
    const hemiLight = new THREE.HemisphereLight(0xa0b080, 0x60704a, 0.6);
    scene.add(hemiLight);
    
    // Add subtle directional light for depth
    const dirLight = new THREE.DirectionalLight(0x9aaa7a, 0.3);
    dirLight.position.set(0, 5, -10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    dirLight.shadow.camera.near = 0.5;
    dirLight.shadow.camera.far = 50;
    scene.add(dirLight);
    
    console.log('Physically correct lighting added');
    
    // Controls
    const keys = {};
    let mouseX = 0;
    let mouseY = 0;
    let pointerLocked = false;
    
    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (e.code === 'Escape' && state.started) {
        state.hudVisible = !state.hudVisible;
        document.getElementById('hud').classList.toggle('show', state.hudVisible);
      }
    });
    
    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });
    
    canvas.addEventListener('click', () => {
      if (!state.started) {
        state.started = true;
        document.getElementById('loading').style.display = 'none';
        console.log('Game started');
      }
      canvas.requestPointerLock();
    });
    
    document.addEventListener('pointerlockchange', () => {
      pointerLocked = document.pointerLockElement === canvas;
    });
    
    document.addEventListener('mousemove', (e) => {
      if (pointerLocked) {
        mouseX -= e.movementX * 0.002;
        mouseY -= e.movementY * 0.002;
        mouseY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, mouseY));
      }
    });
    
    // HUD Controls
    const recordBtn = document.getElementById('recordBtn');
    const attemptCounter = document.getElementById('attemptCounter');
    const feedback = document.getElementById('feedback');
    
    recordBtn.addEventListener('mousedown', () => {
      state.holding = true;
      state.holdStart = Date.now();
      recordBtn.classList.add('holding');
      recordBtn.textContent = 'RECORDING...';
    });
    
    function handleRecordEnd() {
      if (!state.holding) return;
      
      const holdDuration = (Date.now() - state.holdStart) / 1000;
      state.holding = false;
      recordBtn.classList.remove('holding');
      recordBtn.textContent = 'Hold to Record';
      
      if (holdDuration >= 2.0) {
        state.attempts++;
        attemptCounter.textContent = `Attempts: ${state.attempts}`;
        
        if (state.attempts >= state.targetAttempts) {
          state.exitAuthorized = true;
          showFeedback('EXIT AUTHORIZED', true);
          setTimeout(exitExperience, 2000);
        } else {
          showFeedback('NONCOMPLIANT — BEGIN AGAIN.');
        }
      }
    }
    
    recordBtn.addEventListener('mouseup', handleRecordEnd);
    recordBtn.addEventListener('mouseleave', handleRecordEnd);
    
    function showFeedback(message, success = false) {
      feedback.textContent = message;
      feedback.style.display = 'block';
      feedback.style.borderColor = success ? '#008F46' : '#a03030';
      feedback.style.color = success ? '#008F46' : '#ff6060';
      setTimeout(() => {
        feedback.style.display = 'none';
      }, 2000);
    }
    
    function exitExperience() {
      const overlay = document.getElementById('fadeOverlay');
      overlay.classList.add('active');
      setTimeout(() => {
        document.getElementById('hud').innerHTML = '<div class="hud-message" style="color: #008F46; font-size: 24px;">EXIT COMPLETE</div>';
      }, 500);
    }
    
    // Collision detection
    function checkCollision(x, z, radius) {
      for (let wall of collisionWalls) {
        const expandedMinX = wall.minX - radius;
        const expandedMaxX = wall.maxX + radius;
        const expandedMinZ = wall.minZ - radius;
        const expandedMaxZ = wall.maxZ + radius;
        
        if (x >= expandedMinX && x <= expandedMaxX && z >= expandedMinZ && z <= expandedMaxZ) {
          return true;
        }
      }
      return false;
    }
    
    // Movement with collision
    const moveSpeed = 4;
    let bobPhase = 0;
    const playerRadius = 0.3;
    
    function updateMovement(delta) {
      if (!state.started) return;
      
      const velocity = new THREE.Vector3();
      let isMoving = false;
      
      if (keys['KeyW']) { velocity.z = -1; isMoving = true; }
      if (keys['KeyS']) { velocity.z = 1; isMoving = true; }
      if (keys['KeyA']) { velocity.x = -1; isMoving = true; }
      if (keys['KeyD']) { velocity.x = 1; isMoving = true; }
      
      if (velocity.length() > 0) {
        velocity.normalize();
        
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        direction.y = 0;
        direction.normalize();
        
        const right = new THREE.Vector3();
        right.crossVectors(camera.up, direction).normalize();
        
        const moveZ = direction.clone().multiplyScalar(velocity.z * moveSpeed * delta);
        const moveX = right.clone().multiplyScalar(-velocity.x * moveSpeed * delta);
        
        const oldX = camera.position.x;
        const oldZ = camera.position.z;
        const newX = oldX + moveX.x + moveZ.x;
        const newZ = oldZ + moveX.z + moveZ.z;
        
        if (!checkCollision(newX, newZ, playerRadius)) {
          camera.position.x = newX;
          camera.position.z = newZ;
        } else {
          const tryX = oldX + moveX.x;
          if (!checkCollision(tryX, oldZ, playerRadius)) {
            camera.position.x = tryX;
          }
          
          const tryZ = oldZ + moveZ.z;
          if (!checkCollision(oldX, tryZ, playerRadius)) {
            camera.position.z = tryZ;
          }
        }
        
        // Realistic head bob
        bobPhase += delta * 6;
        camera.position.y = 1.6 + Math.sin(bobPhase) * 0.015;
      } else {
        camera.position.y += (1.6 - camera.position.y) * delta * 5;
      }
      
      camera.rotation.order = 'YXZ';
      camera.rotation.y = mouseX;
      camera.rotation.x = mouseY;
      
      // Corridor recycling for endless effect
      const playerSection = Math.round(camera.position.z / 20);
      
      corridors.forEach(corridor => {
        const diff = corridor.index - playerSection;
        
        if (Math.abs(diff) > 3) {
          corridor.index = playerSection + (diff > 0 ? 3 : -3);
          corridor.mesh.position.z = corridor.index * 20;
        }
      });
    }
    
    // Animation loop
    const clock = new THREE.Clock();
    let frameCount = 0;
    
    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      const time = clock.getElapsedTime();
      
      updateMovement(delta);
      
      // Realistic subtle panel flicker
      scene.traverse((obj) => {
        if (obj.userData.isPanel) {
          const flicker = Math.sin(time * 0.4 + obj.userData.flickerPhase) * 0.15;
          const randomNoise = (Math.random() - 0.5) * 0.05;
          obj.material.emissiveIntensity = obj.userData.baseIntensity + flicker + randomNoise;
        }
      });
      
      renderer.render(scene, camera);
      
      frameCount++;
      if (frameCount === 1) {
        console.log('First frame rendered with PBR!');
        document.getElementById('loading').textContent = 'CLICK TO START';
      }
    }
    
    animate();
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    setTimeout(() => {
      if (state.started) {
        state.hudVisible = true;
        document.getElementById('hud').classList.add('show');
      }
    }, 8000);
    
    console.log('Setup complete with full PBR pipeline!');