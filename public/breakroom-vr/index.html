<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Greenwash Backroom</title>
  <style>
    @font-face {
      font-family: 'PPNeueMontreal';
      src: url('./fonts/PPNeueMontreal-Medium.otf') format('opentype');
      font-weight: 500;
      font-style: normal;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'PPNeueMontreal', sans-serif;
      overflow: hidden;
      background: #000;
    }
    
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
      filter: contrast(1.08) saturate(0.85) brightness(0.95);
    }
    
    /* iOS-style glass pill used for hover labels */
    .gw-glass {
      color: #fff;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 9999px;
      padding: 8px 14px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(16px) saturate(180%);
      -webkit-backdrop-filter: blur(16px) saturate(180%);
      font-weight: 500;
    }

    /* Light silver glass for profile and circle hover labels */
    .gw-glass-light {
      color: #008F46;
      background: rgba(217, 217, 217, 0.3);
      border: 1px solid rgba(217, 217, 217, 0.4);
      border-radius: 9999px;
      padding: 8px 14px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(16px) saturate(180%);
      -webkit-backdrop-filter: blur(16px) saturate(180%);
      font-weight: 500;
    }

    /* Profile dropdown uses rectangular glass */
    .gw-glass-light.profile-dropdown {
      border-radius: 12px;
      padding: 12px 16px;
    }

    /* Dark glass for Ministry of Love and other dark modals */
    .gw-glass-dark {
      color: var(--gw-green);
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(0, 143, 70, 0.3);
      border-radius: 12px;
      padding: 12px 16px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(0, 143, 70, 0.2);
      backdrop-filter: blur(16px) saturate(180%);
      -webkit-backdrop-filter: blur(16px) saturate(180%);
      font-weight: 500;
    }

    :root { 
      --gw-green: #008F46; 
    }
    
    #hud {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(16px);
      padding: 30px 40px;
      border-radius: 12px;
      border: 1px solid rgba(0, 143, 70, 0.3);
      text-align: center;
      max-width: 500px;
      display: none;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(0, 143, 70, 0.2);
    }
    
    #hud.show {
      display: block;
    }
    
    .hud-title {
      color: #008F46;
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 20px;
      letter-spacing: 3px;
      text-transform: uppercase;
    }
    
    .hud-message {
      color: #00a653;
      font-size: 16px;
      line-height: 1.8;
      margin-bottom: 25px;
      font-weight: 300;
    }
    
    .hud-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }
    
    #recordBtn {
      background: #008F46;
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'PPNeueMontreal', sans-serif;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.3s;
      letter-spacing: 2px;
      text-transform: uppercase;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    
    #recordBtn:hover {
      background: #00a653;
    }
    
    #recordBtn.holding {
      background: #005a2b;
      box-shadow: 0 0 20px rgba(0, 143, 70, 0.5);
    }
    
    #attemptCounter {
      color: #008F46;
      font-size: 12px;
      letter-spacing: 1px;
    }
    
    #feedback {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      color: #008F46;
      padding: 15px 30px;
      font-size: 14px;
      font-weight: 500;
      display: none;
      z-index: 1000;
      letter-spacing: 2px;
    }
    
    #feedback.gw-glass-dark {
      border-radius: 8px;
    }
    
    #instructions {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(0, 143, 70, 0.8);
      font-size: 11px;
      text-align: center;
      z-index: 10;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    
    #fadeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
      z-index: 2000;
    }
    
    #fadeOverlay.active {
      opacity: 1;
    }
    
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #008F46;
      font-size: 20px;
      z-index: 5000;
      letter-spacing: 2px;
    }
    
    #vignette {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 20%, rgba(0, 0, 0, 0.3) 70%, rgba(0, 0, 0, 0.6) 100%);
      z-index: 1;
      mix-blend-mode: multiply;
    }
    
    #filmGrain {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
      opacity: 0.08;
      background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDAiIGhlaWdodD0iMzAwIj48ZmlsdGVyIGlkPSJhIj48ZmVUdXJidWxlbmNlIGJhc2VGcmVxdWVuY3k9Ii43NSIgc3RpdGNoVGlsZXM9InN0aXRjaCIgdHlwZT0iZnJhY3RhbE5vaXNlIi8+PGZlQ29sb3JNYXRyaXggdHlwZT0ic2F0dXJhdGUiIHZhbHVlcz0iMCIvPjwvZmlsdGVyPjxwYXRoIGQ9Ik0wIDBoMzAwdjMwMEgweiIgZmlsdGVyPSJ1cmwoI2EpIiBvcGFjaXR5PSIuNSIvPjwvc3ZnPg==');
    }

    #doorPrompt {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #008F46;
      font-size: 18px;
      text-align: center;
      z-index: 50;
      padding: 20px 30px;
      display: none;
      letter-spacing: 2px;
    }
    
    #doorPrompt.show {
      display: block;
    }
  </style>
</head>
<body>
  <div id="loading">Loading...</div>
  <canvas id="canvas"></canvas>
  <div id="vignette"></div>
  <div id="filmGrain"></div>
  
  <div id="doorPrompt" class="gw-glass-dark">
    Press E to approach the door
  </div>
  
  <div id="hud">
    <div class="hud-title">Compliance Recital</div>
    <div class="hud-message">
      "Uniform green is policy. Compliance is a public good. I affirm my role in Greenwash."
    </div>
    <div class="hud-controls">
      <button id="recordBtn">Hold to Record</button>
      <div id="attemptCounter">Attempts: 0</div>
    </div>
  </div>

  <div id="feedback"></div>
  <div id="instructions" class="gw-glass-light">Click to start • WASD to move • Mouse to look • E to interact with door</div>
  <div id="fadeOverlay"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // Game state
    const state = {
      attempts: 0,
      targetAttempts: Math.floor(Math.random() * 100) + 1,
      exitAuthorized: false,
      hudVisible: false,
      holding: false,
      holdStart: 0,
      started: false,
      nearDoor: false,
      hallwaysPassed: 0
    };

    console.log('Target attempts:', state.targetAttempts);

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f140f);
    scene.fog = new THREE.Fog(0x2a3520, 3, 35);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.6, 0);

    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.5;
    renderer.physicallyCorrectLights = true;

    // Textures (simplified for performance)
    function createCarpetTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      for (let y = 0; y < 512; y += 4) {
        for (let x = 0; x < 512; x += 4) {
          const baseR = 74 + Math.random() * 20 - 10;
          const baseG = 72 + Math.random() * 18 - 9;
          const baseB = 53 + Math.random() * 15 - 7;
          ctx.fillStyle = `rgb(${baseR}, ${baseG}, ${baseB})`;
          ctx.fillRect(x, y, 4, 4);
        }
      }
      
      for (let i = 0; i < 4000; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const brightness = Math.random() * 40 - 20;
        ctx.fillStyle = `rgba(${80 + brightness}, ${75 + brightness}, ${55 + brightness}, 0.5)`;
        ctx.fillRect(x, y, 1, 2);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.encoding = THREE.sRGBEncoding;
      return texture;
    }
    
    function createWallTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      for (let y = 0; y < 512; y += 2) {
        for (let x = 0; x < 512; x += 2) {
          const baseR = 122 + Math.random() * 16 - 8;
          const baseG = 133 + Math.random() * 14 - 7;
          const baseB = 96 + Math.random() * 12 - 6;
          ctx.fillStyle = `rgb(${baseR}, ${baseG}, ${baseB})`;
          ctx.fillRect(x, y, 2, 2);
        }
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.encoding = THREE.sRGBEncoding;
      return texture;
    }
    
    function createCeilingTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Base painted ceiling color
      for (let y = 0; y < 512; y += 2) {
        for (let x = 0; x < 512; x += 2) {
          const baseR = 138 + Math.random() * 16 - 8;
          const baseG = 148 + Math.random() * 14 - 7;
          const baseB = 117 + Math.random() * 12 - 6;
          ctx.fillStyle = `rgb(${baseR}, ${baseG}, ${baseB})`;
          ctx.fillRect(x, y, 2, 2);
        }
      }
      
      // Water stains
      ctx.globalAlpha = 0.25;
      for (let i = 0; i < 8; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const size = Math.random() * 50 + 30;
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
        gradient.addColorStop(0, '#5a5d48');
        gradient.addColorStop(1, 'rgba(90, 93, 72, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(x - size, y - size, size * 2, size * 2);
      }
      
      // Paint texture details
      ctx.globalAlpha = 0.4;
      for (let i = 0; i < 1500; i++) {
        const brightness = Math.random() * 30 - 15;
        ctx.fillStyle = `rgb(${138 + brightness}, ${148 + brightness}, ${117 + brightness})`;
        ctx.fillRect(Math.random() * 512, Math.random() * 512, 1, 1);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.encoding = THREE.sRGBEncoding;
      return texture;
    }

    const carpetColor = createCarpetTexture();
    carpetColor.repeat.set(12, 12);
    
    const wallColor = createWallTexture();
    wallColor.repeat.set(2, 1);
    
    const ceilingColor = createCeilingTexture();
    ceilingColor.repeat.set(4, 4);

    // Materials
    const floorMaterial = new THREE.MeshStandardMaterial({
      map: carpetColor,
      roughness: 0.98,
      metalness: 0
    });
    
    const wallMaterial = new THREE.MeshStandardMaterial({
      map: wallColor,
      roughness: 0.88,
      metalness: 0
    });

    const ceilingMaterial = new THREE.MeshStandardMaterial({
      map: ceilingColor,
      roughness: 0.92,
      metalness: 0
    });

    const panelMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xb8c4a8,
      emissiveIntensity: 3.5,
      roughness: 0.25,
      metalness: 0.08
    });

    const doorMaterial = new THREE.MeshStandardMaterial({
      color: 0x3a4a2a,
      roughness: 0.7,
      metalness: 0.1
    });

    // Collision system
    const collisionWalls = [];
    let doorMesh = null;
    
    function createCorridor() {
      const group = new THREE.Group();
      const width = 3;
      const height = 2.7;
      const length = 40; // Longer hallway

      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(width, length),
        floorMaterial
      );
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      group.add(floor);

      // Ceiling with realistic drop ceiling tiles
      const tileSize = 0.6;
      const numTilesWidth = Math.ceil(width / tileSize);
      const numTilesLength = Math.ceil(length / tileSize);
      
      // Create individual ceiling tiles
      for (let x = 0; x < numTilesWidth; x++) {
        for (let z = 0; z < numTilesLength; z++) {
          const tile = new THREE.Mesh(
            new THREE.PlaneGeometry(tileSize - 0.01, tileSize - 0.01),
            ceilingMaterial.clone()
          );
          tile.rotation.x = Math.PI / 2;
          const posX = (x - numTilesWidth / 2) * tileSize + tileSize / 2;
          const posZ = (z - numTilesLength / 2) * tileSize + tileSize / 2;
          tile.position.set(posX, height - 0.01, posZ);
          tile.receiveShadow = true;
          group.add(tile);
        }
      }
      
      // Ceiling grid framework (dark green metal)
      const gridMaterial = new THREE.MeshStandardMaterial({
        color: 0x4a5a3a,
        roughness: 0.7,
        metalness: 0.3
      });
      
      const gridThickness = 0.02;
      const gridDepth = 0.03;
      
      // Horizontal grid lines
      for (let z = -length / 2; z <= length / 2; z += tileSize) {
        const grid = new THREE.Mesh(
          new THREE.BoxGeometry(width, gridDepth, gridThickness),
          gridMaterial
        );
        grid.position.set(0, height - gridDepth / 2, z);
        grid.castShadow = true;
        group.add(grid);
      }
      
      // Vertical grid lines
      for (let x = -width / 2; x <= width / 2; x += tileSize) {
        const grid = new THREE.Mesh(
          new THREE.BoxGeometry(gridThickness, gridDepth, length),
          gridMaterial
        );
        grid.position.set(x, height - gridDepth / 2, 0);
        grid.castShadow = true;
        group.add(grid);
      }
      
      // Walls
      const leftWall = new THREE.Mesh(
        new THREE.PlaneGeometry(length, height),
        wallMaterial
      );
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.set(-width / 2, height / 2, 0);
      leftWall.receiveShadow = true;
      leftWall.castShadow = true;
      group.add(leftWall);
      
      const rightWall = new THREE.Mesh(
        new THREE.PlaneGeometry(length, height),
        wallMaterial
      );
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.set(width / 2, height / 2, 0);
      rightWall.receiveShadow = true;
      rightWall.castShadow = true;
      group.add(rightWall);
      
      // Baseboards
      const baseboardMaterial = new THREE.MeshStandardMaterial({
        color: 0x3a3d28,
        roughness: 0.8,
        metalness: 0
      });
      
      const baseboardHeight = 0.08;
      const baseboardDepth = 0.02;
      
      const leftBaseboard = new THREE.Mesh(
        new THREE.BoxGeometry(length, baseboardHeight, baseboardDepth),
        baseboardMaterial
      );
      leftBaseboard.position.set(-width / 2 + baseboardDepth / 2, baseboardHeight / 2, 0);
      leftBaseboard.rotation.y = Math.PI / 2;
      leftBaseboard.receiveShadow = true;
      group.add(leftBaseboard);
      
      const rightBaseboard = new THREE.Mesh(
        new THREE.BoxGeometry(length, baseboardHeight, baseboardDepth),
        baseboardMaterial
      );
      rightBaseboard.position.set(width / 2 - baseboardDepth / 2, baseboardHeight / 2, 0);
      rightBaseboard.rotation.y = Math.PI / 2;
      rightBaseboard.receiveShadow = true;
      group.add(rightBaseboard);
      
      // Door at the end
      const door = new THREE.Mesh(
        new THREE.BoxGeometry(1.2, 2.2, 0.1),
        doorMaterial
      );
      door.position.set(0, 1.1, -length / 2 + 0.05);
      door.castShadow = true;
      door.receiveShadow = true;
      door.userData.isDoor = true;
      group.add(door);
      doorMesh = door;
      
      // Door frame
      const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2d1a, roughness: 0.8 });
      const frameThickness = 0.1;
      
      const topFrame = new THREE.Mesh(
        new THREE.BoxGeometry(1.4, frameThickness, frameThickness),
        frameMaterial
      );
      topFrame.position.set(0, 2.2, -length / 2);
      group.add(topFrame);
      
      const leftFrame = new THREE.Mesh(
        new THREE.BoxGeometry(frameThickness, 2.4, frameThickness),
        frameMaterial
      );
      leftFrame.position.set(-0.7, 1.2, -length / 2);
      group.add(leftFrame);
      
      const rightFrame = new THREE.Mesh(
        new THREE.BoxGeometry(frameThickness, 2.4, frameThickness),
        frameMaterial
      );
      rightFrame.position.set(0.7, 1.2, -length / 2);
      group.add(rightFrame);
      
      // Realistic ceiling panels - recessed fixtures
      for (let z = -length / 2 + 4; z < length / 2 - 4; z += 3.6) {
        // Recessed housing/frame
        const housingMaterial = new THREE.MeshStandardMaterial({
          color: 0x5a6550,
          roughness: 0.85,
          metalness: 0.1
        });
        
        const housing = new THREE.Mesh(
          new THREE.BoxGeometry(1.3, 0.08, 0.65),
          housingMaterial
        );
        housing.position.set(0, height - 0.08, z);
        housing.receiveShadow = true;
        group.add(housing);
        
        // Light diffuser panel (translucent)
        const diffuserMaterial = new THREE.MeshStandardMaterial({
          color: 0xf5f5e8,
          emissive: 0xc8d4b8,
          emissiveIntensity: 4.5,
          roughness: 0.4,
          metalness: 0,
          opacity: 0.9,
          transparent: true
        });
        
        const panel = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 0.02, 0.6),
          diffuserMaterial
        );
        panel.position.set(0, height - 0.04, z);
        panel.userData.isPanel = true;
        panel.userData.baseIntensity = 4.5;
        panel.castShadow = false;
        group.add(panel);
        
        // Bright point light from inside fixture
        const light = new THREE.PointLight(0xc8d4b8, 6, 20);
        light.position.set(0, height - 0.1, z);
        light.decay = 2;
        light.castShadow = false;
        group.add(light);
      }
      
      // Collision walls
      collisionWalls.push({
        minX: -width / 2 - 0.1,
        maxX: -width / 2 + 0.1,
        minZ: -length / 2,
        maxZ: length / 2
      });
      
      collisionWalls.push({
        minX: width / 2 - 0.1,
        maxX: width / 2 + 0.1,
        minZ: -length / 2,
        maxZ: length / 2
      });
      
      // Back wall collision (door wall)
      collisionWalls.push({
        minX: -width / 2,
        maxX: width / 2,
        minZ: -length / 2 - 0.1,
        maxZ: -length / 2 + 0.1
      });

      return group;
    }

    // Create initial corridor
    const corridor = createCorridor();
    scene.add(corridor);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x6a7a5a, 0.4);
    scene.add(ambientLight);

    const hemiLight = new THREE.HemisphereLight(0x808a60, 0x4a5438, 0.5);
    scene.add(hemiLight);
    
    const dirLight = new THREE.DirectionalLight(0x7a8a6a, 0.3);
    dirLight.position.set(0, 10, -10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    scene.add(dirLight);

    // Controls
    const keys = {};
    let mouseX = 0;
    let mouseY = 0;
    let pointerLocked = false;

    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      
      if (e.code === 'KeyE' && state.nearDoor && !state.hudVisible) {
        state.hudVisible = true;
        document.getElementById('hud').classList.add('show');
        document.getElementById('doorPrompt').classList.remove('show');
      }
      
      if (e.code === 'Escape' && state.started) {
        if (state.hudVisible && !state.nearDoor) {
          state.hudVisible = false;
          document.getElementById('hud').classList.remove('show');
        }
      }
    });

    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    canvas.addEventListener('click', () => {
      if (!state.started) {
        state.started = true;
        document.getElementById('loading').style.display = 'none';
      }
      canvas.requestPointerLock();
    });

    document.addEventListener('pointerlockchange', () => {
      pointerLocked = document.pointerLockElement === canvas;
    });

    document.addEventListener('mousemove', (e) => {
      if (pointerLocked) {
        mouseX -= e.movementX * 0.002;
        mouseY -= e.movementY * 0.002;
        mouseY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, mouseY));
      }
    });

    // HUD
    const recordBtn = document.getElementById('recordBtn');
    const attemptCounter = document.getElementById('attemptCounter');
    const feedback = document.getElementById('feedback');

    recordBtn.addEventListener('mousedown', () => {
      state.holding = true;
      state.holdStart = Date.now();
      recordBtn.classList.add('holding');
      recordBtn.textContent = 'RECORDING...';
    });

    function handleRecordEnd() {
      if (!state.holding) return;

      const holdDuration = (Date.now() - state.holdStart) / 1000;
      state.holding = false;
      recordBtn.classList.remove('holding');
      recordBtn.textContent = 'Hold to Record';

      if (holdDuration >= 2.0) {
        state.attempts++;
        attemptCounter.textContent = `Attempts: ${state.attempts}`;

        if (state.attempts >= state.targetAttempts) {
          state.exitAuthorized = true;
          showFeedback('COMPLIANCE ACCEPTED', true);
          setTimeout(() => {
            document.getElementById('hud').classList.remove('show');
            state.hudVisible = false;
            openDoor();
          }, 1500);
        } else {
          showFeedback('NONCOMPLIANT — DOOR REMAINS LOCKED');
          setTimeout(() => {
            document.getElementById('hud').classList.remove('show');
            state.hudVisible = false;
            resetToStart();
          }, 2000);
        }
      }
    }

    recordBtn.addEventListener('mouseup', handleRecordEnd);
    recordBtn.addEventListener('mouseleave', handleRecordEnd);

    function showFeedback(message, success = false) {
      feedback.textContent = message;
      feedback.className = 'gw-glass-dark';
      feedback.style.display = 'block';
      feedback.style.borderColor = success ? '#008F46' : '#a03030';
      feedback.style.color = success ? '#008F46' : '#ff6060';
      setTimeout(() => {
        feedback.style.display = 'none';
      }, 2000);
    }
    
    function openDoor() {
      // Exit to homepage
      const overlay = document.getElementById('fadeOverlay');
      overlay.classList.add('active');
      setTimeout(() => {
        window.location.href = '/';
      }, 1000);
    }

    function resetToStart() {
      // Reset player to start of hallway
      camera.position.set(0, 1.6, 18);
      state.nearDoor = false;
      state.hallwaysPassed++;
      
      // Generate new random target
      state.targetAttempts = Math.floor(Math.random() * 100) + 1;
      state.attempts = 0;
      attemptCounter.textContent = 'Attempts: 0';
      console.log('New target attempts:', state.targetAttempts);
    }
    
    // Collision
    function checkCollision(x, z, radius) {
      for (let wall of collisionWalls) {
        if (x >= wall.minX - radius && x <= wall.maxX + radius && 
            z >= wall.minZ - radius && z <= wall.maxZ + radius) {
          return true;
        }
      }
      return false;
    }
    
    // Movement
    const moveSpeed = 4;
    let bobPhase = 0;
    const playerRadius = 0.3;

    function updateMovement(delta) {
      if (!state.started || state.hudVisible) return;

      const velocity = new THREE.Vector3();
      
      if (keys['KeyW']) velocity.z = 1;
      if (keys['KeyS']) velocity.z = -1;
      if (keys['KeyA']) velocity.x = -1;
      if (keys['KeyD']) velocity.x = 1;

      if (velocity.length() > 0) {
        velocity.normalize();

        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        direction.y = 0;
        direction.normalize();

        const right = new THREE.Vector3();
        right.crossVectors(camera.up, direction).normalize();

        const moveZ = direction.clone().multiplyScalar(velocity.z * moveSpeed * delta);
        const moveX = right.clone().multiplyScalar(-velocity.x * moveSpeed * delta);
        
        const oldX = camera.position.x;
        const oldZ = camera.position.z;
        const newX = oldX + moveX.x + moveZ.x;
        const newZ = oldZ + moveX.z + moveZ.z;
        
        if (!checkCollision(newX, newZ, playerRadius)) {
          camera.position.x = newX;
          camera.position.z = newZ;
        } else {
          const tryX = oldX + moveX.x;
          if (!checkCollision(tryX, oldZ, playerRadius)) {
            camera.position.x = tryX;
          }
          
          const tryZ = oldZ + moveZ.z;
          if (!checkCollision(oldX, tryZ, playerRadius)) {
            camera.position.z = tryZ;
          }
        }
        
        bobPhase += delta * 6;
        camera.position.y = 1.6 + Math.sin(bobPhase) * 0.015;
      } else {
        camera.position.y += (1.6 - camera.position.y) * delta * 5;
      }

      camera.rotation.order = 'YXZ';
      camera.rotation.y = mouseX;
      camera.rotation.x = mouseY;

      // Check if near door
      if (doorMesh) {
        const doorPos = new THREE.Vector3();
        doorMesh.getWorldPosition(doorPos);
        const distance = camera.position.distanceTo(doorPos);
        
        if (distance < 3 && !state.nearDoor) {
          state.nearDoor = true;
          document.getElementById('doorPrompt').classList.add('show');
        } else if (distance >= 3 && state.nearDoor) {
          state.nearDoor = false;
          document.getElementById('doorPrompt').classList.remove('show');
        }
      }
    }
    
    // Animation
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const time = clock.getElapsedTime();

      updateMovement(delta);

      // Panel flicker
      scene.traverse((obj) => {
        if (obj.userData.isPanel) {
          const flicker = Math.sin(time * 0.3) * 0.15 + (Math.random() - 0.5) * 0.05;
          obj.material.emissiveIntensity = obj.userData.baseIntensity + flicker;
        }
      });

      renderer.render(scene, camera);
    }
    
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    setTimeout(() => {
      document.getElementById('loading').textContent = 'CLICK TO START';
    }, 100);
  </script>
</body>
</html>